{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This ugly but useful graph with insets and labels was drawn with pippi Pippi: Computer music with python v2.0.0 - Beta 4 (In Development) What is this? Pippi is a computer music library for python. It includes a few handy data structures for music like SoundBuffer & Wavetable , which are operator-overloaded to make working with sounds and control structures simpler. It also includes a lot of useful methods for doing common and not-so-common transformations to sounds and control structures. from pippi import dsp sound1 = dsp . read ( 'sound1.wav' ) sound2 = dsp . read ( 'sound2.flac' ) # Mix two sounds both = sound1 & sound2 # Apply a skewed hann Wavetable as an envelope to a sound enveloped = sound * dsp . win ( 'hann' ) . skewed ( 0.6 ) # Or the same, via a shortcut method on the `SoundBuffer` enveloped = sound . env ( 'hann' ) # Synthesize a 10 second graincloud from the sound, # with grain length modulating between 20ms and 2s # over a hann shaped curve. cloudy = enveloped . cloud ( 10 , grainlength = dsp . win ( 'hann' , dsp . MS * 20 , 2 )) It comes with several oscs: - Pulsar - a pulsar synthesis engine - Pulsar2d - a 2d morphing pulsar synthesis engine - Tukey - a tukey-window-based osc with waveshape modulation between square-like and sine-like - Osc - an everyday wavetable osc - Osc2d - a 2d morphing wavetable osc - Fold - an infinite folding wavetable osc - Bar - a bar physical model (from Soundpipe) - Pluck - a plucked string physical model (adapted from JOS) - Alias - a highly aliased pulse train osc And many built-in effects and transformations: - Easy independent control over pitch and speed for any `SoundBuffer` - Paulstretch - Several forms of waveshaping and distortion including a crossover distortion ported from supercollider - Sweapable highpass , lowpass , bandpass and band reject butterworth filters from Soundpipe - Lots more ! As well as support for pitch and harmony transformations and non-standard tuning systems from pippi import tune # Get a list of frequencies from a list of scale degrees frequencies = tune . fromdegrees ([ 1 , 3 , 5 , 9 ], octave = 3 , root = 'a' , scale = tune . MINOR , ratios = tune . JUST ) # Get a list of frequencies from a chord symbol using a tuning system devised by Terry Riley frequencies = tune . chord ( 'ii69' , key = 'g#' , octave = 5 , ratios = tune . TERRY ) # Convert MIDI note to frequency freq = tune . mtof ( 60 ) # Convert frequency to MIDI note note = tune . ftom ( 440.0 ) # Convert a pitch to a frequency freq = tune . ntf ( 'C#3' ) And basic graphing functionality for any SoundBuffer or Wavetable -- some dumb examples pictured in the banner above. from pippi import dsp sound = dsp . read ( 'sound.wav' ) # Render an image of this sound's waveform sound . graph ( 'mysound.png' ) # Render an image of a sinc wavetable with a label and scaled range dsp . win ( 'sinc' ) . graph ( 'sinc.png' , label = 'A sinc wavetable' , y = ( -. 25 , 1 )) As well as other neat stuff like soundfont rendering support via tinysf! from pippi import dsp , soundfont # Play a piano sound from a soundfont with general MIDI support (program change is zero-indexed) tada = soundfont . play ( 'my-cool-soundfont.sf2' , length = 30 , freq = 345.9 , amp = 0.5 , voice = 0 ) # Save copy to your hard disk tada . write ( 'tada.wav' ) Installation Pippi requires python 3.6+ which can be found here: https://www.python.org/downloads/ The 3.5.x branch of python might work too, but is untested. To use the most recent release from pip (currently 2.0.0 beta 3 ) just: pip install pippi But! Please see below about installing the latest version from source, there are a lot of new features in the most recent beta. Tutorials There are annotated example scripts in the tutorials directory which introduce some of pippi's functionality. Beyond arriving at a good-enough stable API for the 2.x series of releases (and fixing bugs), my goal during the beta phase of development is to deal with the lack of documentation for this project. Install from source raspbian buster users: you must install the libatlas-base-dev package with apt to build the latest version of numpy. To install pippi: make install Which does a few things: Installs python deps, so make sure you're inside a virtual environment if you want to be! Sets up git submodules for external libs Builds and installs Soundpipe Builds and installs pippi & cython extensions Please let me know if you run into problems! To run tests make test In many cases, this will produce a soundfile in the tests/renders directory for the corresponding test. (Ear-driven regression testing...) During the beta I like to keep failing tests in the main repo, so... most tests will be passing but if they all are passing, probably you are living in the future and are looking at the first stable release. There are also shortcuts to run only certain groups of tests, like test-wavesets -- check out the Makefile for a list of them all. Hacking While hacking on pippi itself, running make build will recompile the cython extensions. If you need to build sources from a clean slate (sometimes updates to pxd files require this) then run make clean build instead. Thanks Project Nayuki for a compact FFT! (Used in SoundBuffer.convolve() ) Paul Batchelor for all the goodness in Soundpipe that has made its way into Pippi. (See the fx and bar modules.) Bernhard Schelling for his TinySoundFont library used in the soundfont module. Nando Florestan for his small public domain GM soundfont used in the test suite. Pixeldroid for their OFL licensed console font used for labeling graphs.","title":"Home"},{"location":"#pippi-computer-music-with-python","text":"v2.0.0 - Beta 4 (In Development)","title":"Pippi: Computer music with python"},{"location":"#what-is-this","text":"Pippi is a computer music library for python. It includes a few handy data structures for music like SoundBuffer & Wavetable , which are operator-overloaded to make working with sounds and control structures simpler. It also includes a lot of useful methods for doing common and not-so-common transformations to sounds and control structures. from pippi import dsp sound1 = dsp . read ( 'sound1.wav' ) sound2 = dsp . read ( 'sound2.flac' ) # Mix two sounds both = sound1 & sound2 # Apply a skewed hann Wavetable as an envelope to a sound enveloped = sound * dsp . win ( 'hann' ) . skewed ( 0.6 ) # Or the same, via a shortcut method on the `SoundBuffer` enveloped = sound . env ( 'hann' ) # Synthesize a 10 second graincloud from the sound, # with grain length modulating between 20ms and 2s # over a hann shaped curve. cloudy = enveloped . cloud ( 10 , grainlength = dsp . win ( 'hann' , dsp . MS * 20 , 2 )) It comes with several oscs: - Pulsar - a pulsar synthesis engine - Pulsar2d - a 2d morphing pulsar synthesis engine - Tukey - a tukey-window-based osc with waveshape modulation between square-like and sine-like - Osc - an everyday wavetable osc - Osc2d - a 2d morphing wavetable osc - Fold - an infinite folding wavetable osc - Bar - a bar physical model (from Soundpipe) - Pluck - a plucked string physical model (adapted from JOS) - Alias - a highly aliased pulse train osc And many built-in effects and transformations: - Easy independent control over pitch and speed for any `SoundBuffer` - Paulstretch - Several forms of waveshaping and distortion including a crossover distortion ported from supercollider - Sweapable highpass , lowpass , bandpass and band reject butterworth filters from Soundpipe - Lots more ! As well as support for pitch and harmony transformations and non-standard tuning systems from pippi import tune # Get a list of frequencies from a list of scale degrees frequencies = tune . fromdegrees ([ 1 , 3 , 5 , 9 ], octave = 3 , root = 'a' , scale = tune . MINOR , ratios = tune . JUST ) # Get a list of frequencies from a chord symbol using a tuning system devised by Terry Riley frequencies = tune . chord ( 'ii69' , key = 'g#' , octave = 5 , ratios = tune . TERRY ) # Convert MIDI note to frequency freq = tune . mtof ( 60 ) # Convert frequency to MIDI note note = tune . ftom ( 440.0 ) # Convert a pitch to a frequency freq = tune . ntf ( 'C#3' ) And basic graphing functionality for any SoundBuffer or Wavetable -- some dumb examples pictured in the banner above. from pippi import dsp sound = dsp . read ( 'sound.wav' ) # Render an image of this sound's waveform sound . graph ( 'mysound.png' ) # Render an image of a sinc wavetable with a label and scaled range dsp . win ( 'sinc' ) . graph ( 'sinc.png' , label = 'A sinc wavetable' , y = ( -. 25 , 1 )) As well as other neat stuff like soundfont rendering support via tinysf! from pippi import dsp , soundfont # Play a piano sound from a soundfont with general MIDI support (program change is zero-indexed) tada = soundfont . play ( 'my-cool-soundfont.sf2' , length = 30 , freq = 345.9 , amp = 0.5 , voice = 0 ) # Save copy to your hard disk tada . write ( 'tada.wav' )","title":"What is this?"},{"location":"#installation","text":"Pippi requires python 3.6+ which can be found here: https://www.python.org/downloads/ The 3.5.x branch of python might work too, but is untested. To use the most recent release from pip (currently 2.0.0 beta 3 ) just: pip install pippi But! Please see below about installing the latest version from source, there are a lot of new features in the most recent beta.","title":"Installation"},{"location":"#tutorials","text":"There are annotated example scripts in the tutorials directory which introduce some of pippi's functionality. Beyond arriving at a good-enough stable API for the 2.x series of releases (and fixing bugs), my goal during the beta phase of development is to deal with the lack of documentation for this project.","title":"Tutorials"},{"location":"#install-from-source","text":"raspbian buster users: you must install the libatlas-base-dev package with apt to build the latest version of numpy. To install pippi: make install Which does a few things: Installs python deps, so make sure you're inside a virtual environment if you want to be! Sets up git submodules for external libs Builds and installs Soundpipe Builds and installs pippi & cython extensions Please let me know if you run into problems!","title":"Install from source"},{"location":"#to-run-tests","text":"make test In many cases, this will produce a soundfile in the tests/renders directory for the corresponding test. (Ear-driven regression testing...) During the beta I like to keep failing tests in the main repo, so... most tests will be passing but if they all are passing, probably you are living in the future and are looking at the first stable release. There are also shortcuts to run only certain groups of tests, like test-wavesets -- check out the Makefile for a list of them all.","title":"To run tests"},{"location":"#hacking","text":"While hacking on pippi itself, running make build will recompile the cython extensions. If you need to build sources from a clean slate (sometimes updates to pxd files require this) then run make clean build instead.","title":"Hacking"},{"location":"#thanks","text":"Project Nayuki for a compact FFT! (Used in SoundBuffer.convolve() ) Paul Batchelor for all the goodness in Soundpipe that has made its way into Pippi. (See the fx and bar modules.) Bernhard Schelling for his TinySoundFont library used in the soundfont module. Nando Florestan for his small public domain GM soundfont used in the test suite. Pixeldroid for their OFL licensed console font used for labeling graphs.","title":"Thanks"},{"location":"CHANGELOG/","text":"Release Notes 2.0.0 - Beta 4 Breaking Changes Flip-flopped back to using strings for name lookups when calling from python. (Internally flags are still used in many places for performance.) So use eg dsp.wt('sine') instead of dsp.wt(dsp.SINE) or sound.pan(0.1, method='gogins') etc. Wavetable / window options are: sine sinein sineout cos tri saw phasor rsaw hann hamm black or blackman bart or bartlett kaiser rnd line hannin hannout gauss gaussin gaussout pluckin pluckout square sinc Panning types: constant linear sine gogins Features Removed all the old examples and wrote the first tutorial script. The first set of soundpipe modules are now available via the fx module! fx.lpf , fx.hpf , fx.bpf , and fx.brf butterworth filters. fx.compressor ... a compressor. fx.mincer a phase vocoder with independent control over pitch and speed. fx.paulstretch ... paulstretch. fx.saturator a saturation distortion. A new Waveset datatype for Trevor Wishart-style microsound synthesis and easy creation of wavetable stacks for 2d oscs. Featuring: Waveset substitution Single waveform substitution (replace all wavesets with a sinewave, for example) Waveset collection substitution (replace wavesets with a collection of wavetables or another waveset) Waveform morph substitution (replace wavesets with an lfo-controlled morph through a wavetable stack) (in progress) Waveset normalization Waveset time-stretching Waveset reversal Waveset retrograde (reversing the contents of the wavesets while preserving their order) Waveset harmonic distortion (in progress) Waveset transposition (in progress) Waveset morphing (in progress) Waveset inversion (in progress) Broke oscs up into smaller units and added a few new ones consisting of: Osc which is a simple wavetable osc Osc2d a simple 2d wavetable osc Pulsar a pulsar synthesis implementation (now with pulsewidth modulation!) Pulsar2d the same which accepts optional wavetable stacks for the wavetable and window params Fold an implementation of an infinite wavetable folder Pluck a basic implementation of a plucked string physical model which can be fed with an arbitrary wavetable impulse DSS an implementation of dynamic stochastic synthesis (in progress) Alias a single-sample aliasing pulsetrain osc Total rewrite of grains.GrainCloud , now grains.Cloud (and SoundBuffer.cloud ) Uses mincer for pitch shifting Grainlength and grain density are no longer tightly coupled: no more density param. It is replaced with a grainlength value/wavetable and a grid value/wavetable. Grain masking Many params can be given as either a fixed-value float (like 1.3 ), a built-in wavetable flag (like hannout or rnd ), or a wavetable-like object (a list, numpy array, sound buffer, etc). EG a cloud frozen in time Cloud(position=0.75) , advancing linearly through time Cloud(position='phasor') , or interpolated through four points in time Cloud(position=[0, 1, 0.25, 0.75]) . A simple envelope follower interface on SoundBuffer which produces a Wavetable via SoundBuffer.toenv() , also available as fx.envelope_follower() A SoundBuffer -to- Wavetable shortcut via SoundBuffer.towavetable() Bugfixes Some cython extension packaging improvements Many misc bugfixes, I lost track... probably also at least a few shiny new bugs as well 2.0.0 - Beta 3 Features Basic FIR filter with filters.fir or fx.convolve SoundBuffer normalization with fx.norm Get SoundBuffer magnitude with dsp.mag Single and multitap delays with fx.delay and fx.mdelay Some new built-in wavetable.window types: dsp.SINEIN / dsp.SINEOUT , dsp.HANNIN / dsp.HANNOUT for fades More flexible frequency table creation from arbitrary scales, tunings and scale bitmasks with tune.tofreqs Bugfixes Fix phase overflow in interpolation._linear_point Fixed a nasty bug when loading mono soundfiles from disk. 2.0.0 - Beta 2 Features Point interpolation with interpolation.linear_point Bugfixes Examples can be run from anywhere Interpolation fixes Performance Optimizations Faster ADSR wavetable generation Faster pitch shifting Faster interpolation Faster grain cloud generation Some misc SoundBuffer performance improvements (more to come) 2.0.0 - Beta 1 Features Added fx module Added first pass fx.go granular overdrive effect. See examples/fxgo_example.py for usage. Bugfixes Fixed a packaging issue preventing the tune module from loading. Better overflow handling in SoundBuffer.adsr and wavetables.adsr Fixed a bug with SoundBuffer.remix when mixing to a single channel Fixed a bug during Wavetable initialization when using wavetable flags to create a window. 2.0.0 - Alpha 9 Final feature releases / big api changes before going to beta. Breaking changes: Durations for most APIs are now given in seconds (floats) rather than integer frames. len(SoundBuffer) still returns a length in frames per python convention, and slicing into a SoundBuffer is also still done by frame (and channel) but there is a new SoundBuffer.dur property to get duration in seconds as well. Wavetables are no longer specified with string names, instead built-in flags which are available on both the wavetable and dsp modules are used. Eg to apply a sinewave envelop: sound.env(dsp.SINE) instead of sound.env('sine') . The wavetypes available are SINE , COS , TRI , SAW (which is also aliased to PHASOR ), RSAW (reverse sawtooth), HANN , HAMM , BLACK or BLACKMAN , BART or BARTLETT , KAISER , SQUARE , and the RND flag to select one at random. Osc changes: Added 2d wavetable synthesis (similar to max/msp 2d.wave~ ) to Osc plus example script To create a 2d Osc , use the stack keyword arg on initialization: Osc(stack=[dsp.RND, [0,1], dsp.SINE], lfo=dsp.SINE) Osc wavetables may be: an int flag for standard wavetables ( dsp.SINE , dsp.TRI , etc) a python list of floats ( [0,1,0.5,0.3] ) a wavetable ( wavetables.Wavetable([0,1,0,1]) ) a soundbuffer ( soundbuffer.SoundBuffer(filename='something.flac') ) 2d wavetable stacks are a python list of any combination of the above. The same types are acceptable for: wavetable (the basic waveform) window (an optional window to apply to the waveform wavetable - useful for eg pulsar synthesis) mod (the frequency modulation wavetable) and lfo (the 2d modulation wavetable) SoundBuffer changes: Added remix for remixing a soundbuffer from N channels to N channels. Panning algorithms operate on arbitrary numbers of channels (but use same algorithms applied to odd & even numbered channels instead of left & right) Return a reversed copy of a soundbuffer with sound.reversed() or reverse in place with sound.reverse() New ADSR envelopes with sound.adsr(a=1, d=1, s=0.5, r=1) Generate a GrainCloud from a SoundBuffer with sound.cloud() Clip samples to min/max with sound.clip(minval=-1, maxval=1) Taper ends of sounds (linear fade-in, fade-out) with sound.taper(length) ADSR wavetable generator with wavetables.adsr(a=100, d=100, s=0.5, r=100, 1024) New Wavetable type for SoundBuffer -like operator-overloaded wavetable manipulation & composition New GrainCloud wavetable-driven granulator. See the examples/swarmy_graincloud.py example for more. GrainCloud -driven pitch shift without time change ( sound.transpose(speed) ) and time stretch without pitch shift ( sound.stretch(length) ) methods for SoundBuffer . dsp.cloud(SoundBuffer, *args, **kwargs) shortcut for GrainCloud creation. Read wavetables from 1 channel sound files with wavetables.fromfile Added a simple helper for async rendering with multiprocessing.Pool SoundBuffer s can now be pickled (enables passing them between processes) SoundBuffer can be initialized (and spread across channels) from a normal python list 2.0.0 - Alpha 6-8 This was meant to be a feature-only release, to add the final round of features before going into beta / bugfix mode. Instead I switched from using numpy arrays directly to a first pass of a more general typed memoryview approach, and moved some more things into cython. Also, hoo boy was pip install pippi ever broken . It should be working now. 2.0.0 - Alpha 5 Bugfix release. Fixed an idiotic regression in SoundBuffer . 2.0.0 - Alpha 4 New in alpha 4: More speed improvements! Linear interpolation option for pitch shifting Pulsar synthesis with Osc Support for importing Scala .scl tuning files (Mapping file support coming later...) Waveform visualization with graph.waveform SoundBuffer.fill returns a copy of the sound instead of altering it in place Sampler abstraction for Osc -like treatment of samples and banks of samples 2.0.0 - Alpha 3 Optimizations and improvements in this release: Much better performance for wavetable and granular synthesis Improvements and additions to the rhythm modules Better handling of rhythm.curve which now takes a length param instead of an obscure combination of multipliers rhythm.curve can now be provided a custom wavetable Added MPC swing helper for onset lists (via rhythm.swing ) Added a euclidean rhythm generator rhythm.eu Added a pattern generation helper rhythm.pattern Added pattern-to-onset and string-to-pattern helpers Patterns are the same as pippi 1 (I may even just port some code) and can be in a few forms: String literals with ascii notation eg: 'xx x- x' which is the same as 'xx.x-.x' Lists of 'truthy' and 'falsey' values eg: ['1', True, 0, False] which is the same as 'xx..' Misc bugfixes: Fix random param for wavetable.window and wavetable.window Fix bad params for wavetable.window and wavetable.window -- falls back to sine in both cases 2.0.0 - Alpha 2 This release includes a few missing pieces to core functionality including: A crude squarewave wavetype for the wavetable osc! Custom wavetables for the wavetable osc and window/wavetable generators! See the simple_custom_wavetable.py example for use with the wavetable osc. A simple non-interpolating speed method on SoundBuffer for pitch shifting sounds A set of rhythm helpers in the rhythm module useful for constructing onset / timing lists. rhythm.curve which lets you map any of the window types to a list of onsets -- check out the simple_snare_bounce.py example in the examples directory. Some more example scripts including: simple_snare_bounce.py Demoing the rhythm.curve helper multi_snare_bounce.py A more interesting variation on the snare bounce example simple_custom_wavetable.py Showing a user-defined wavetable used with Osc synth_chords.py Using the tune module with Osc to create a simple chord progression 2.0.0 - Alpha 1 This is the initial alpha release of pippi 2 -- which is very barebones at the moment, but already pretty functional! Beware: the behavior of core functionality and features will probably change throughout the alpha releases of pippi 2. I'll try to document it here in the release notes. This release provides: SoundBuffer abstraction for reading/writing soundfiles and doing basic operations on sounds. Osc abstraction for simple wavetable synthesis. Initial set of built-in wavetables for windowing (sine, triangle, saw, inverse saw) and synthesis (sine, cosine, triangle, saw inverse saw) Set of panning algorithms and other built-in sound operations like addition, subtraction, multiplication, mixing (and operater-overloaded mixing via sound &= sound ), dubbing, concatenation. A small set of helpers and shortcuts via the dsp module for loading, mixing, and concatenating (via dsp.join ) sounds. Basic granular synthesis and wavetable synthesis examples.","title":"Changelog"},{"location":"CHANGELOG/#release-notes","text":"","title":"Release Notes"},{"location":"CHANGELOG/#200-beta-4","text":"","title":"2.0.0 - Beta 4"},{"location":"CHANGELOG/#breaking-changes","text":"Flip-flopped back to using strings for name lookups when calling from python. (Internally flags are still used in many places for performance.) So use eg dsp.wt('sine') instead of dsp.wt(dsp.SINE) or sound.pan(0.1, method='gogins') etc. Wavetable / window options are: sine sinein sineout cos tri saw phasor rsaw hann hamm black or blackman bart or bartlett kaiser rnd line hannin hannout gauss gaussin gaussout pluckin pluckout square sinc Panning types: constant linear sine gogins","title":"Breaking Changes"},{"location":"CHANGELOG/#features","text":"Removed all the old examples and wrote the first tutorial script. The first set of soundpipe modules are now available via the fx module! fx.lpf , fx.hpf , fx.bpf , and fx.brf butterworth filters. fx.compressor ... a compressor. fx.mincer a phase vocoder with independent control over pitch and speed. fx.paulstretch ... paulstretch. fx.saturator a saturation distortion. A new Waveset datatype for Trevor Wishart-style microsound synthesis and easy creation of wavetable stacks for 2d oscs. Featuring: Waveset substitution Single waveform substitution (replace all wavesets with a sinewave, for example) Waveset collection substitution (replace wavesets with a collection of wavetables or another waveset) Waveform morph substitution (replace wavesets with an lfo-controlled morph through a wavetable stack) (in progress) Waveset normalization Waveset time-stretching Waveset reversal Waveset retrograde (reversing the contents of the wavesets while preserving their order) Waveset harmonic distortion (in progress) Waveset transposition (in progress) Waveset morphing (in progress) Waveset inversion (in progress) Broke oscs up into smaller units and added a few new ones consisting of: Osc which is a simple wavetable osc Osc2d a simple 2d wavetable osc Pulsar a pulsar synthesis implementation (now with pulsewidth modulation!) Pulsar2d the same which accepts optional wavetable stacks for the wavetable and window params Fold an implementation of an infinite wavetable folder Pluck a basic implementation of a plucked string physical model which can be fed with an arbitrary wavetable impulse DSS an implementation of dynamic stochastic synthesis (in progress) Alias a single-sample aliasing pulsetrain osc Total rewrite of grains.GrainCloud , now grains.Cloud (and SoundBuffer.cloud ) Uses mincer for pitch shifting Grainlength and grain density are no longer tightly coupled: no more density param. It is replaced with a grainlength value/wavetable and a grid value/wavetable. Grain masking Many params can be given as either a fixed-value float (like 1.3 ), a built-in wavetable flag (like hannout or rnd ), or a wavetable-like object (a list, numpy array, sound buffer, etc). EG a cloud frozen in time Cloud(position=0.75) , advancing linearly through time Cloud(position='phasor') , or interpolated through four points in time Cloud(position=[0, 1, 0.25, 0.75]) . A simple envelope follower interface on SoundBuffer which produces a Wavetable via SoundBuffer.toenv() , also available as fx.envelope_follower() A SoundBuffer -to- Wavetable shortcut via SoundBuffer.towavetable()","title":"Features"},{"location":"CHANGELOG/#bugfixes","text":"Some cython extension packaging improvements Many misc bugfixes, I lost track... probably also at least a few shiny new bugs as well","title":"Bugfixes"},{"location":"CHANGELOG/#200-beta-3","text":"","title":"2.0.0 - Beta 3"},{"location":"CHANGELOG/#features_1","text":"Basic FIR filter with filters.fir or fx.convolve SoundBuffer normalization with fx.norm Get SoundBuffer magnitude with dsp.mag Single and multitap delays with fx.delay and fx.mdelay Some new built-in wavetable.window types: dsp.SINEIN / dsp.SINEOUT , dsp.HANNIN / dsp.HANNOUT for fades More flexible frequency table creation from arbitrary scales, tunings and scale bitmasks with tune.tofreqs","title":"Features"},{"location":"CHANGELOG/#bugfixes_1","text":"Fix phase overflow in interpolation._linear_point Fixed a nasty bug when loading mono soundfiles from disk.","title":"Bugfixes"},{"location":"CHANGELOG/#200-beta-2","text":"","title":"2.0.0 - Beta 2"},{"location":"CHANGELOG/#features_2","text":"Point interpolation with interpolation.linear_point","title":"Features"},{"location":"CHANGELOG/#bugfixes_2","text":"Examples can be run from anywhere Interpolation fixes","title":"Bugfixes"},{"location":"CHANGELOG/#performance-optimizations","text":"Faster ADSR wavetable generation Faster pitch shifting Faster interpolation Faster grain cloud generation Some misc SoundBuffer performance improvements (more to come)","title":"Performance Optimizations"},{"location":"CHANGELOG/#200-beta-1","text":"","title":"2.0.0 - Beta 1"},{"location":"CHANGELOG/#features_3","text":"Added fx module Added first pass fx.go granular overdrive effect. See examples/fxgo_example.py for usage.","title":"Features"},{"location":"CHANGELOG/#bugfixes_3","text":"Fixed a packaging issue preventing the tune module from loading. Better overflow handling in SoundBuffer.adsr and wavetables.adsr Fixed a bug with SoundBuffer.remix when mixing to a single channel Fixed a bug during Wavetable initialization when using wavetable flags to create a window.","title":"Bugfixes"},{"location":"CHANGELOG/#200-alpha-9","text":"Final feature releases / big api changes before going to beta. Breaking changes: Durations for most APIs are now given in seconds (floats) rather than integer frames. len(SoundBuffer) still returns a length in frames per python convention, and slicing into a SoundBuffer is also still done by frame (and channel) but there is a new SoundBuffer.dur property to get duration in seconds as well. Wavetables are no longer specified with string names, instead built-in flags which are available on both the wavetable and dsp modules are used. Eg to apply a sinewave envelop: sound.env(dsp.SINE) instead of sound.env('sine') . The wavetypes available are SINE , COS , TRI , SAW (which is also aliased to PHASOR ), RSAW (reverse sawtooth), HANN , HAMM , BLACK or BLACKMAN , BART or BARTLETT , KAISER , SQUARE , and the RND flag to select one at random. Osc changes: Added 2d wavetable synthesis (similar to max/msp 2d.wave~ ) to Osc plus example script To create a 2d Osc , use the stack keyword arg on initialization: Osc(stack=[dsp.RND, [0,1], dsp.SINE], lfo=dsp.SINE) Osc wavetables may be: an int flag for standard wavetables ( dsp.SINE , dsp.TRI , etc) a python list of floats ( [0,1,0.5,0.3] ) a wavetable ( wavetables.Wavetable([0,1,0,1]) ) a soundbuffer ( soundbuffer.SoundBuffer(filename='something.flac') ) 2d wavetable stacks are a python list of any combination of the above. The same types are acceptable for: wavetable (the basic waveform) window (an optional window to apply to the waveform wavetable - useful for eg pulsar synthesis) mod (the frequency modulation wavetable) and lfo (the 2d modulation wavetable) SoundBuffer changes: Added remix for remixing a soundbuffer from N channels to N channels. Panning algorithms operate on arbitrary numbers of channels (but use same algorithms applied to odd & even numbered channels instead of left & right) Return a reversed copy of a soundbuffer with sound.reversed() or reverse in place with sound.reverse() New ADSR envelopes with sound.adsr(a=1, d=1, s=0.5, r=1) Generate a GrainCloud from a SoundBuffer with sound.cloud() Clip samples to min/max with sound.clip(minval=-1, maxval=1) Taper ends of sounds (linear fade-in, fade-out) with sound.taper(length) ADSR wavetable generator with wavetables.adsr(a=100, d=100, s=0.5, r=100, 1024) New Wavetable type for SoundBuffer -like operator-overloaded wavetable manipulation & composition New GrainCloud wavetable-driven granulator. See the examples/swarmy_graincloud.py example for more. GrainCloud -driven pitch shift without time change ( sound.transpose(speed) ) and time stretch without pitch shift ( sound.stretch(length) ) methods for SoundBuffer . dsp.cloud(SoundBuffer, *args, **kwargs) shortcut for GrainCloud creation. Read wavetables from 1 channel sound files with wavetables.fromfile Added a simple helper for async rendering with multiprocessing.Pool SoundBuffer s can now be pickled (enables passing them between processes) SoundBuffer can be initialized (and spread across channels) from a normal python list","title":"2.0.0 - Alpha 9"},{"location":"CHANGELOG/#200-alpha-6-8","text":"This was meant to be a feature-only release, to add the final round of features before going into beta / bugfix mode. Instead I switched from using numpy arrays directly to a first pass of a more general typed memoryview approach, and moved some more things into cython. Also, hoo boy was pip install pippi ever broken . It should be working now.","title":"2.0.0 - Alpha 6-8"},{"location":"CHANGELOG/#200-alpha-5","text":"Bugfix release. Fixed an idiotic regression in SoundBuffer .","title":"2.0.0 - Alpha 5"},{"location":"CHANGELOG/#200-alpha-4","text":"New in alpha 4: More speed improvements! Linear interpolation option for pitch shifting Pulsar synthesis with Osc Support for importing Scala .scl tuning files (Mapping file support coming later...) Waveform visualization with graph.waveform SoundBuffer.fill returns a copy of the sound instead of altering it in place Sampler abstraction for Osc -like treatment of samples and banks of samples","title":"2.0.0 - Alpha 4"},{"location":"CHANGELOG/#200-alpha-3","text":"Optimizations and improvements in this release: Much better performance for wavetable and granular synthesis Improvements and additions to the rhythm modules Better handling of rhythm.curve which now takes a length param instead of an obscure combination of multipliers rhythm.curve can now be provided a custom wavetable Added MPC swing helper for onset lists (via rhythm.swing ) Added a euclidean rhythm generator rhythm.eu Added a pattern generation helper rhythm.pattern Added pattern-to-onset and string-to-pattern helpers Patterns are the same as pippi 1 (I may even just port some code) and can be in a few forms: String literals with ascii notation eg: 'xx x- x' which is the same as 'xx.x-.x' Lists of 'truthy' and 'falsey' values eg: ['1', True, 0, False] which is the same as 'xx..' Misc bugfixes: Fix random param for wavetable.window and wavetable.window Fix bad params for wavetable.window and wavetable.window -- falls back to sine in both cases","title":"2.0.0 - Alpha 3"},{"location":"CHANGELOG/#200-alpha-2","text":"This release includes a few missing pieces to core functionality including: A crude squarewave wavetype for the wavetable osc! Custom wavetables for the wavetable osc and window/wavetable generators! See the simple_custom_wavetable.py example for use with the wavetable osc. A simple non-interpolating speed method on SoundBuffer for pitch shifting sounds A set of rhythm helpers in the rhythm module useful for constructing onset / timing lists. rhythm.curve which lets you map any of the window types to a list of onsets -- check out the simple_snare_bounce.py example in the examples directory. Some more example scripts including: simple_snare_bounce.py Demoing the rhythm.curve helper multi_snare_bounce.py A more interesting variation on the snare bounce example simple_custom_wavetable.py Showing a user-defined wavetable used with Osc synth_chords.py Using the tune module with Osc to create a simple chord progression","title":"2.0.0 - Alpha 2"},{"location":"CHANGELOG/#200-alpha-1","text":"This is the initial alpha release of pippi 2 -- which is very barebones at the moment, but already pretty functional! Beware: the behavior of core functionality and features will probably change throughout the alpha releases of pippi 2. I'll try to document it here in the release notes. This release provides: SoundBuffer abstraction for reading/writing soundfiles and doing basic operations on sounds. Osc abstraction for simple wavetable synthesis. Initial set of built-in wavetables for windowing (sine, triangle, saw, inverse saw) and synthesis (sine, cosine, triangle, saw inverse saw) Set of panning algorithms and other built-in sound operations like addition, subtraction, multiplication, mixing (and operater-overloaded mixing via sound &= sound ), dubbing, concatenation. A small set of helpers and shortcuts via the dsp module for loading, mixing, and concatenating (via dsp.join ) sounds. Basic granular synthesis and wavetable synthesis examples.","title":"2.0.0 - Alpha 1"},{"location":"reference/pippi/","text":"Module pippi Sub-modules pippi.algos pippi.alias pippi.bar pippi.benchmarks pippi.defaults pippi.drummachine pippi.dsp pippi.dss pippi.fft pippi.fold pippi.fx pippi.grains pippi.graph pippi.interpolation pippi.lists pippi.noise pippi.osc pippi.osc2d pippi.oscs pippi.pluck pippi.pulsar pippi.pulsar2d pippi.rand pippi.rhythm pippi.sampler pippi.shapes pippi.soundbuffer pippi.soundfont pippi.soundpipe pippi.tukey pippi.tune pippi.wavesets pippi.wavetables","title":"Index"},{"location":"reference/pippi/#module-pippi","text":"","title":"Module pippi"},{"location":"reference/pippi/#sub-modules","text":"pippi.algos pippi.alias pippi.bar pippi.benchmarks pippi.defaults pippi.drummachine pippi.dsp pippi.dss pippi.fft pippi.fold pippi.fx pippi.grains pippi.graph pippi.interpolation pippi.lists pippi.noise pippi.osc pippi.osc2d pippi.oscs pippi.pluck pippi.pulsar pippi.pulsar2d pippi.rand pippi.rhythm pippi.sampler pippi.shapes pippi.soundbuffer pippi.soundfont pippi.soundpipe pippi.tukey pippi.tune pippi.wavesets pippi.wavetables","title":"Sub-modules"},{"location":"reference/pippi/algos/","text":"Module pippi.algos View Source # -*- coding : utf - 8 -*- # R value threshold of chaos for logistic map . \u5728\u7ebf\u627e\u6211 rchaos = 3 . 569945671870944901842 Variables rchaos","title":"Algos"},{"location":"reference/pippi/algos/#module-pippialgos","text":"View Source # -*- coding : utf - 8 -*- # R value threshold of chaos for logistic map . \u5728\u7ebf\u627e\u6211 rchaos = 3 . 569945671870944901842","title":"Module pippi.algos"},{"location":"reference/pippi/algos/#variables","text":"rchaos","title":"Variables"},{"location":"reference/pippi/alias/","text":"Module pippi.alias Classes Alias class Alias ( / , * args , ** kwargs ) Single-sample aliasing pulse train osc Class variables amp channels freq samplerate Methods play def play ( ... )","title":"Alias"},{"location":"reference/pippi/alias/#module-pippialias","text":"","title":"Module pippi.alias"},{"location":"reference/pippi/alias/#classes","text":"","title":"Classes"},{"location":"reference/pippi/alias/#alias","text":"class Alias ( / , * args , ** kwargs ) Single-sample aliasing pulse train osc","title":"Alias"},{"location":"reference/pippi/alias/#class-variables","text":"amp channels freq samplerate","title":"Class variables"},{"location":"reference/pippi/alias/#methods","text":"","title":"Methods"},{"location":"reference/pippi/alias/#play","text":"def play ( ... )","title":"play"},{"location":"reference/pippi/bar/","text":"Module pippi.bar Classes Bar class Bar ( / , * args , ** kwargs ) Class variables amp barpos channels decay leftclamp loss rightclamp samplerate scan stiffness velocity width wtsize Methods play def play ( ... )","title":"Bar"},{"location":"reference/pippi/bar/#module-pippibar","text":"","title":"Module pippi.bar"},{"location":"reference/pippi/bar/#classes","text":"","title":"Classes"},{"location":"reference/pippi/bar/#bar","text":"class Bar ( / , * args , ** kwargs )","title":"Bar"},{"location":"reference/pippi/bar/#class-variables","text":"amp barpos channels decay leftclamp loss rightclamp samplerate scan stiffness velocity width wtsize","title":"Class variables"},{"location":"reference/pippi/bar/#methods","text":"","title":"Methods"},{"location":"reference/pippi/bar/#play","text":"def play ( ... )","title":"play"},{"location":"reference/pippi/benchmarks/","text":"Module pippi.benchmarks Run this with python -m pippi.benchmarks to see some timing information for synthesis etc. View Source \"\"\" Run this with `python -m pippi.benchmarks` to see some timing information for synthesis etc. \"\"\" import timeit init = \"\"\" \\ from pippi import oscs osc = oscs.Osc() \"\"\" basic = \"\"\" \\ from pippi import oscs osc = oscs.Osc() out = osc.play({length}) \"\"\" pwsine = \"\"\" \\ from pippi import oscs, wavetables, dsp wavetable = wavetables.wavetable(dsp.SINE, {wtsize}) window = wavetables.window(dsp.SINE, {wtsize}) pulsewidth = 0.95 osc = oscs.Osc(wavetable, window=window, pulsewidth=pulsewidth) out = osc.play({length}) \"\"\" pwsinemod = \"\"\" \\ from pippi import oscs, wavetables, dsp wavetable = wavetables.wavetable(dsp.SINE, {wtsize}) window = wavetables.window(dsp.SINE, {wtsize}) mod = wavetables.window(dsp.SINE, {wtsize}) pulsewidth = 0.95 osc = oscs.Osc(wavetable, window=window, mod=mod, pulsewidth=pulsewidth) out = osc.play({length}) \"\"\" if __name__ == '__main__' : wtsize = 4096 init_time = timeit . timeit ( stmt = init , number = 1000 ) print ( 'init 1000x...' ) print ( round ( init_time , 2 ), ' \\n ' , init ) run_times = [ ( 1 , 44100 * 10 ), ( 10 , 44100 * 10 ), ( 100 , 44100 * 10 ), ] print ( '' ) print ( 'basic' ) for nruns , length in run_times : print ( ' %s %s second renders w/default settings...' % ( nruns , round ( length / 44100 , 2 ))) basic_time = timeit . timeit ( stmt = basic . format ( length = length ), number = nruns ) t = round ( basic_time , 2 ) print ( 'total time %s \\n %s %s \\n %s seconds' % ( t , round ( t / nruns , 2 ), 'avg per run' , basic . format ( length = length ))) print ( '' ) print ( '' ) print ( 'pulsewidth w/sine window' ) for nruns , length in run_times : print ( ' %s %s second renders pulsewidth w/sine window...' % ( nruns , round ( length / 44100 , 2 ))) pwsine_time = timeit . timeit ( stmt = pwsine . format ( length = length , wtsize = wtsize ), number = nruns ) t = round ( pwsine_time , 2 ) print ( 'total time %s \\n %s %s \\n %s seconds' % ( t , round ( t / nruns , 2 ), 'avg per run' , pwsine . format ( length = length , wtsize = wtsize ))) print ( '' ) print ( '' ) print ( 'pulsewidth w/sine window & mod' ) for nruns , length in run_times : print ( ' %s %s second renders pulsewidth w/sine window & mod...' % ( nruns , round ( length / 44100 , 2 ))) pwsinemod_time = timeit . timeit ( stmt = pwsinemod . format ( length = length , wtsize = wtsize ), number = nruns ) t = round ( pwsinemod_time , 2 ) print ( 'total time %s \\n %s %s \\n %s seconds' % ( t , round ( t / nruns , 2 ), 'avg per run' , pwsinemod . format ( length = length , wtsize = wtsize ))) print ( '' ) print ( '' ) Variables basic init pwsine pwsinemod","title":"Benchmarks"},{"location":"reference/pippi/benchmarks/#module-pippibenchmarks","text":"Run this with python -m pippi.benchmarks to see some timing information for synthesis etc. View Source \"\"\" Run this with `python -m pippi.benchmarks` to see some timing information for synthesis etc. \"\"\" import timeit init = \"\"\" \\ from pippi import oscs osc = oscs.Osc() \"\"\" basic = \"\"\" \\ from pippi import oscs osc = oscs.Osc() out = osc.play({length}) \"\"\" pwsine = \"\"\" \\ from pippi import oscs, wavetables, dsp wavetable = wavetables.wavetable(dsp.SINE, {wtsize}) window = wavetables.window(dsp.SINE, {wtsize}) pulsewidth = 0.95 osc = oscs.Osc(wavetable, window=window, pulsewidth=pulsewidth) out = osc.play({length}) \"\"\" pwsinemod = \"\"\" \\ from pippi import oscs, wavetables, dsp wavetable = wavetables.wavetable(dsp.SINE, {wtsize}) window = wavetables.window(dsp.SINE, {wtsize}) mod = wavetables.window(dsp.SINE, {wtsize}) pulsewidth = 0.95 osc = oscs.Osc(wavetable, window=window, mod=mod, pulsewidth=pulsewidth) out = osc.play({length}) \"\"\" if __name__ == '__main__' : wtsize = 4096 init_time = timeit . timeit ( stmt = init , number = 1000 ) print ( 'init 1000x...' ) print ( round ( init_time , 2 ), ' \\n ' , init ) run_times = [ ( 1 , 44100 * 10 ), ( 10 , 44100 * 10 ), ( 100 , 44100 * 10 ), ] print ( '' ) print ( 'basic' ) for nruns , length in run_times : print ( ' %s %s second renders w/default settings...' % ( nruns , round ( length / 44100 , 2 ))) basic_time = timeit . timeit ( stmt = basic . format ( length = length ), number = nruns ) t = round ( basic_time , 2 ) print ( 'total time %s \\n %s %s \\n %s seconds' % ( t , round ( t / nruns , 2 ), 'avg per run' , basic . format ( length = length ))) print ( '' ) print ( '' ) print ( 'pulsewidth w/sine window' ) for nruns , length in run_times : print ( ' %s %s second renders pulsewidth w/sine window...' % ( nruns , round ( length / 44100 , 2 ))) pwsine_time = timeit . timeit ( stmt = pwsine . format ( length = length , wtsize = wtsize ), number = nruns ) t = round ( pwsine_time , 2 ) print ( 'total time %s \\n %s %s \\n %s seconds' % ( t , round ( t / nruns , 2 ), 'avg per run' , pwsine . format ( length = length , wtsize = wtsize ))) print ( '' ) print ( '' ) print ( 'pulsewidth w/sine window & mod' ) for nruns , length in run_times : print ( ' %s %s second renders pulsewidth w/sine window & mod...' % ( nruns , round ( length / 44100 , 2 ))) pwsinemod_time = timeit . timeit ( stmt = pwsinemod . format ( length = length , wtsize = wtsize ), number = nruns ) t = round ( pwsinemod_time , 2 ) print ( 'total time %s \\n %s %s \\n %s seconds' % ( t , round ( t / nruns , 2 ), 'avg per run' , pwsinemod . format ( length = length , wtsize = wtsize ))) print ( '' ) print ( '' )","title":"Module pippi.benchmarks"},{"location":"reference/pippi/benchmarks/#variables","text":"basic init pwsine pwsinemod","title":"Variables"},{"location":"reference/pippi/defaults/","text":"Module pippi.defaults","title":"Defaults"},{"location":"reference/pippi/defaults/#module-pippidefaults","text":"","title":"Module pippi.defaults"},{"location":"reference/pippi/drummachine/","text":"Module pippi.drummachine Classes DrumMachine class DrumMachine ( / , * args , ** kwargs ) Class variables drums Methods add def add ( ... ) play def play ( ... )","title":"Drummachine"},{"location":"reference/pippi/drummachine/#module-pippidrummachine","text":"","title":"Module pippi.drummachine"},{"location":"reference/pippi/drummachine/#classes","text":"","title":"Classes"},{"location":"reference/pippi/drummachine/#drummachine","text":"class DrumMachine ( / , * args , ** kwargs )","title":"DrumMachine"},{"location":"reference/pippi/drummachine/#class-variables","text":"drums","title":"Class variables"},{"location":"reference/pippi/drummachine/#methods","text":"","title":"Methods"},{"location":"reference/pippi/drummachine/#add","text":"def add ( ... )","title":"add"},{"location":"reference/pippi/drummachine/#play","text":"def play ( ... )","title":"play"},{"location":"reference/pippi/dsp/","text":"Module pippi.dsp Variables MS Functions buffer def buffer ( ... ) choice def choice ( ... ) fill def fill ( ... ) find def find ( ... ) Glob for files matching a given pattern and return a generator that will yield each file as a SoundBuffer join def join ( ... ) Concatenate a list of sounds into a new sound load def load ( ... ) mag def mag ( ... ) mix def mix ( ... ) Mix a list of sounds into a new sound pool def pool ( ... ) rand def rand ( ... ) randint def randint ( ... ) randline def randline ( ... ) read def read ( ... ) Read a soundfile from disk and return a SoundBuffer with its contents. May include a start position and length in seconds to read a segment from a large file. The filename param is always converted to a string, so it is safe to pass a Path instance from the standard library pathlib module. redrum def redrum ( ... ) scale def scale ( ... ) seed def seed ( ... ) snap def snap ( ... ) stack def stack ( ... ) win def win ( ... ) wt def wt ( ... )","title":"Dsp"},{"location":"reference/pippi/dsp/#module-pippidsp","text":"","title":"Module pippi.dsp"},{"location":"reference/pippi/dsp/#variables","text":"MS","title":"Variables"},{"location":"reference/pippi/dsp/#functions","text":"","title":"Functions"},{"location":"reference/pippi/dsp/#buffer","text":"def buffer ( ... )","title":"buffer"},{"location":"reference/pippi/dsp/#choice","text":"def choice ( ... )","title":"choice"},{"location":"reference/pippi/dsp/#fill","text":"def fill ( ... )","title":"fill"},{"location":"reference/pippi/dsp/#find","text":"def find ( ... ) Glob for files matching a given pattern and return a generator that will yield each file as a SoundBuffer","title":"find"},{"location":"reference/pippi/dsp/#join","text":"def join ( ... ) Concatenate a list of sounds into a new sound","title":"join"},{"location":"reference/pippi/dsp/#load","text":"def load ( ... )","title":"load"},{"location":"reference/pippi/dsp/#mag","text":"def mag ( ... )","title":"mag"},{"location":"reference/pippi/dsp/#mix","text":"def mix ( ... ) Mix a list of sounds into a new sound","title":"mix"},{"location":"reference/pippi/dsp/#pool","text":"def pool ( ... )","title":"pool"},{"location":"reference/pippi/dsp/#rand","text":"def rand ( ... )","title":"rand"},{"location":"reference/pippi/dsp/#randint","text":"def randint ( ... )","title":"randint"},{"location":"reference/pippi/dsp/#randline","text":"def randline ( ... )","title":"randline"},{"location":"reference/pippi/dsp/#read","text":"def read ( ... ) Read a soundfile from disk and return a SoundBuffer with its contents. May include a start position and length in seconds to read a segment from a large file. The filename param is always converted to a string, so it is safe to pass a Path instance from the standard library pathlib module.","title":"read"},{"location":"reference/pippi/dsp/#redrum","text":"def redrum ( ... )","title":"redrum"},{"location":"reference/pippi/dsp/#scale","text":"def scale ( ... )","title":"scale"},{"location":"reference/pippi/dsp/#seed","text":"def seed ( ... )","title":"seed"},{"location":"reference/pippi/dsp/#snap","text":"def snap ( ... )","title":"snap"},{"location":"reference/pippi/dsp/#stack","text":"def stack ( ... )","title":"stack"},{"location":"reference/pippi/dsp/#win","text":"def win ( ... )","title":"win"},{"location":"reference/pippi/dsp/#wt","text":"def wt ( ... )","title":"wt"},{"location":"reference/pippi/dss/","text":"Module pippi.dss Classes DSS class DSS ( / , * args , ** kwargs ) 1d or 2d wavetable osc Class variables amp channels freq mod_freq mod_phase mod_range phase pulsewidth samplerate win_phase wtsize Methods play def play ( ... )","title":"Dss"},{"location":"reference/pippi/dss/#module-pippidss","text":"","title":"Module pippi.dss"},{"location":"reference/pippi/dss/#classes","text":"","title":"Classes"},{"location":"reference/pippi/dss/#dss","text":"class DSS ( / , * args , ** kwargs ) 1d or 2d wavetable osc","title":"DSS"},{"location":"reference/pippi/dss/#class-variables","text":"amp channels freq mod_freq mod_phase mod_range phase pulsewidth samplerate win_phase wtsize","title":"Class variables"},{"location":"reference/pippi/dss/#methods","text":"","title":"Methods"},{"location":"reference/pippi/dss/#play","text":"def play ( ... )","title":"play"},{"location":"reference/pippi/fft/","text":"Module pippi.fft Functions conv def conv ( ... )","title":"Fft"},{"location":"reference/pippi/fft/#module-pippifft","text":"","title":"Module pippi.fft"},{"location":"reference/pippi/fft/#functions","text":"","title":"Functions"},{"location":"reference/pippi/fft/#conv","text":"def conv ( ... )","title":"conv"},{"location":"reference/pippi/fold/","text":"Module pippi.fold Classes Fold class Fold ( / , * args , ** kwargs ) Folding wavetable oscilator Class variables amp factFreq factors freq wavetable Methods play def play ( ... )","title":"Fold"},{"location":"reference/pippi/fold/#module-pippifold","text":"","title":"Module pippi.fold"},{"location":"reference/pippi/fold/#classes","text":"","title":"Classes"},{"location":"reference/pippi/fold/#fold","text":"class Fold ( / , * args , ** kwargs ) Folding wavetable oscilator","title":"Fold"},{"location":"reference/pippi/fold/#class-variables","text":"amp factFreq factors freq wavetable","title":"Class variables"},{"location":"reference/pippi/fold/#methods","text":"","title":"Methods"},{"location":"reference/pippi/fold/#play","text":"def play ( ... )","title":"play"},{"location":"reference/pippi/fx/","text":"Module pippi.fx Functions bpf def bpf ( ... ) brf def brf ( ... ) compressor def compressor ( ... ) convolve def convolve ( ... ) crossfade def crossfade ( ... ) crossover def crossover ( ... ) Crossover distortion ported from the supercollider CrossoverDistortion ugen crush def crush ( ... ) delay def delay ( ... ) distort def distort ( ... ) Non-linear distortion ported from supercollider envelope_follower def envelope_follower ( ... ) fir def fir ( ... ) go def go ( ... ) hpf def hpf ( ... ) lpf def lpf ( ... ) mdelay def mdelay ( ... ) mincer def mincer ( ... ) norm def norm ( ... ) paulstretch def paulstretch ( ... ) saturator def saturator ( ... ) softclip def softclip ( ... ) Soft clip ported from supercollider vdelay def vdelay ( ... ) vspeed def vspeed ( ... ) widen def widen ( ... )","title":"Fx"},{"location":"reference/pippi/fx/#module-pippifx","text":"","title":"Module pippi.fx"},{"location":"reference/pippi/fx/#functions","text":"","title":"Functions"},{"location":"reference/pippi/fx/#bpf","text":"def bpf ( ... )","title":"bpf"},{"location":"reference/pippi/fx/#brf","text":"def brf ( ... )","title":"brf"},{"location":"reference/pippi/fx/#compressor","text":"def compressor ( ... )","title":"compressor"},{"location":"reference/pippi/fx/#convolve","text":"def convolve ( ... )","title":"convolve"},{"location":"reference/pippi/fx/#crossfade","text":"def crossfade ( ... )","title":"crossfade"},{"location":"reference/pippi/fx/#crossover","text":"def crossover ( ... ) Crossover distortion ported from the supercollider CrossoverDistortion ugen","title":"crossover"},{"location":"reference/pippi/fx/#crush","text":"def crush ( ... )","title":"crush"},{"location":"reference/pippi/fx/#delay","text":"def delay ( ... )","title":"delay"},{"location":"reference/pippi/fx/#distort","text":"def distort ( ... ) Non-linear distortion ported from supercollider","title":"distort"},{"location":"reference/pippi/fx/#envelope_follower","text":"def envelope_follower ( ... )","title":"envelope_follower"},{"location":"reference/pippi/fx/#fir","text":"def fir ( ... )","title":"fir"},{"location":"reference/pippi/fx/#go","text":"def go ( ... )","title":"go"},{"location":"reference/pippi/fx/#hpf","text":"def hpf ( ... )","title":"hpf"},{"location":"reference/pippi/fx/#lpf","text":"def lpf ( ... )","title":"lpf"},{"location":"reference/pippi/fx/#mdelay","text":"def mdelay ( ... )","title":"mdelay"},{"location":"reference/pippi/fx/#mincer","text":"def mincer ( ... )","title":"mincer"},{"location":"reference/pippi/fx/#norm","text":"def norm ( ... )","title":"norm"},{"location":"reference/pippi/fx/#paulstretch","text":"def paulstretch ( ... )","title":"paulstretch"},{"location":"reference/pippi/fx/#saturator","text":"def saturator ( ... )","title":"saturator"},{"location":"reference/pippi/fx/#softclip","text":"def softclip ( ... ) Soft clip ported from supercollider","title":"softclip"},{"location":"reference/pippi/fx/#vdelay","text":"def vdelay ( ... )","title":"vdelay"},{"location":"reference/pippi/fx/#vspeed","text":"def vspeed ( ... )","title":"vspeed"},{"location":"reference/pippi/fx/#widen","text":"def widen ( ... )","title":"widen"},{"location":"reference/pippi/grains/","text":"Module pippi.grains Classes Cloud class Cloud ( / , * args , ** kwargs ) Methods play def play ( ... )","title":"Grains"},{"location":"reference/pippi/grains/#module-pippigrains","text":"","title":"Module pippi.grains"},{"location":"reference/pippi/grains/#classes","text":"","title":"Classes"},{"location":"reference/pippi/grains/#cloud","text":"class Cloud ( / , * args , ** kwargs )","title":"Cloud"},{"location":"reference/pippi/grains/#methods","text":"","title":"Methods"},{"location":"reference/pippi/grains/#play","text":"def play ( ... )","title":"play"},{"location":"reference/pippi/graph/","text":"Module pippi.graph Functions waveform def waveform ( ... ) write def write ( ... )","title":"Graph"},{"location":"reference/pippi/graph/#module-pippigraph","text":"","title":"Module pippi.graph"},{"location":"reference/pippi/graph/#functions","text":"","title":"Functions"},{"location":"reference/pippi/graph/#waveform","text":"def waveform ( ... )","title":"waveform"},{"location":"reference/pippi/graph/#write","text":"def write ( ... )","title":"write"},{"location":"reference/pippi/interpolation/","text":"Module pippi.interpolation Functions linear def linear ( ... ) linear_point def linear_point ( ... ) linear_pos def linear_pos ( ... ) trunc def trunc ( ... ) trunc_point def trunc_point ( ... ) trunc_pos def trunc_pos ( ... )","title":"Interpolation"},{"location":"reference/pippi/interpolation/#module-pippiinterpolation","text":"","title":"Module pippi.interpolation"},{"location":"reference/pippi/interpolation/#functions","text":"","title":"Functions"},{"location":"reference/pippi/interpolation/#linear","text":"def linear ( ... )","title":"linear"},{"location":"reference/pippi/interpolation/#linear_point","text":"def linear_point ( ... )","title":"linear_point"},{"location":"reference/pippi/interpolation/#linear_pos","text":"def linear_pos ( ... )","title":"linear_pos"},{"location":"reference/pippi/interpolation/#trunc","text":"def trunc ( ... )","title":"trunc"},{"location":"reference/pippi/interpolation/#trunc_point","text":"def trunc_point ( ... )","title":"trunc_point"},{"location":"reference/pippi/interpolation/#trunc_pos","text":"def trunc_pos ( ... )","title":"trunc_pos"},{"location":"reference/pippi/lists/","text":"Module pippi.lists Functions scale def scale ( ... ) snap def snap ( ... )","title":"Lists"},{"location":"reference/pippi/lists/#module-pippilists","text":"","title":"Module pippi.lists"},{"location":"reference/pippi/lists/#functions","text":"","title":"Functions"},{"location":"reference/pippi/lists/#scale","text":"def scale ( ... )","title":"scale"},{"location":"reference/pippi/lists/#snap","text":"def snap ( ... )","title":"snap"},{"location":"reference/pippi/noise/","text":"Module pippi.noise Functions bln def bln ( ... )","title":"Noise"},{"location":"reference/pippi/noise/#module-pippinoise","text":"","title":"Module pippi.noise"},{"location":"reference/pippi/noise/#functions","text":"","title":"Functions"},{"location":"reference/pippi/noise/#bln","text":"def bln ( ... )","title":"bln"},{"location":"reference/pippi/osc/","text":"Module pippi.osc Classes Osc class Osc ( / , * args , ** kwargs ) simple wavetable osc with linear interpolation Class variables amp channels freq samplerate wavetable wtsize Methods play def play ( ... )","title":"Osc"},{"location":"reference/pippi/osc/#module-pippiosc","text":"","title":"Module pippi.osc"},{"location":"reference/pippi/osc/#classes","text":"","title":"Classes"},{"location":"reference/pippi/osc/#osc","text":"class Osc ( / , * args , ** kwargs ) simple wavetable osc with linear interpolation","title":"Osc"},{"location":"reference/pippi/osc/#class-variables","text":"amp channels freq samplerate wavetable wtsize","title":"Class variables"},{"location":"reference/pippi/osc/#methods","text":"","title":"Methods"},{"location":"reference/pippi/osc/#play","text":"def play ( ... )","title":"play"},{"location":"reference/pippi/osc2d/","text":"Module pippi.osc2d Classes Osc2d class Osc2d ( / , * args , ** kwargs ) 1d or 2d wavetable osc Class variables amp channels freq lfo_freq mod_freq mod_phase mod_range phase pulsewidth samplerate win_phase wtsize Methods play def play ( ... )","title":"Osc2D"},{"location":"reference/pippi/osc2d/#module-pippiosc2d","text":"","title":"Module pippi.osc2d"},{"location":"reference/pippi/osc2d/#classes","text":"","title":"Classes"},{"location":"reference/pippi/osc2d/#osc2d","text":"class Osc2d ( / , * args , ** kwargs ) 1d or 2d wavetable osc","title":"Osc2d"},{"location":"reference/pippi/osc2d/#class-variables","text":"amp channels freq lfo_freq mod_freq mod_phase mod_range phase pulsewidth samplerate win_phase wtsize","title":"Class variables"},{"location":"reference/pippi/osc2d/#methods","text":"","title":"Methods"},{"location":"reference/pippi/osc2d/#play","text":"def play ( ... )","title":"play"},{"location":"reference/pippi/oscs/","text":"Module pippi.oscs","title":"Oscs"},{"location":"reference/pippi/oscs/#module-pippioscs","text":"","title":"Module pippi.oscs"},{"location":"reference/pippi/pluck/","text":"Module pippi.pluck This is a port of Julius O Smith's pluck.c -- an implementation of digital waveguide synthesis. I've tried to preserve his original comments inline. The original can be found here: https://ccrma.stanford.edu/~jos/pmudw/pluck.c pluck.c - elementary waveguide simulation of plucked strings - JOS 6/6/92 Classes DelayLine class DelayLine ( / , * args , ** kwargs ) Pluck class Pluck ( / , * args , ** kwargs ) Class variables seed Methods get_sample def get_sample ( ... ) next_sample def next_sample ( ... ) play def play ( ... )","title":"Pluck"},{"location":"reference/pippi/pluck/#module-pippipluck","text":"This is a port of Julius O Smith's pluck.c -- an implementation of digital waveguide synthesis. I've tried to preserve his original comments inline. The original can be found here: https://ccrma.stanford.edu/~jos/pmudw/pluck.c pluck.c - elementary waveguide simulation of plucked strings - JOS 6/6/92","title":"Module pippi.pluck"},{"location":"reference/pippi/pluck/#classes","text":"","title":"Classes"},{"location":"reference/pippi/pluck/#delayline","text":"class DelayLine ( / , * args , ** kwargs )","title":"DelayLine"},{"location":"reference/pippi/pluck/#pluck","text":"class Pluck ( / , * args , ** kwargs )","title":"Pluck"},{"location":"reference/pippi/pluck/#class-variables","text":"seed","title":"Class variables"},{"location":"reference/pippi/pluck/#methods","text":"","title":"Methods"},{"location":"reference/pippi/pluck/#get_sample","text":"def get_sample ( ... )","title":"get_sample"},{"location":"reference/pippi/pluck/#next_sample","text":"def next_sample ( ... )","title":"next_sample"},{"location":"reference/pippi/pluck/#play","text":"def play ( ... )","title":"play"},{"location":"reference/pippi/pulsar/","text":"Module pippi.pulsar Classes Pulsar class Pulsar ( / , * args , ** kwargs ) Pulsar synthesis Class variables amp burst channels freq mask pulsewidth samplerate wavetable window Methods play def play ( ... )","title":"Pulsar"},{"location":"reference/pippi/pulsar/#module-pippipulsar","text":"","title":"Module pippi.pulsar"},{"location":"reference/pippi/pulsar/#classes","text":"","title":"Classes"},{"location":"reference/pippi/pulsar/#pulsar","text":"class Pulsar ( / , * args , ** kwargs ) Pulsar synthesis","title":"Pulsar"},{"location":"reference/pippi/pulsar/#class-variables","text":"amp burst channels freq mask pulsewidth samplerate wavetable window","title":"Class variables"},{"location":"reference/pippi/pulsar/#methods","text":"","title":"Methods"},{"location":"reference/pippi/pulsar/#play","text":"def play ( ... )","title":"play"},{"location":"reference/pippi/pulsar2d/","text":"Module pippi.pulsar2d Classes Pulsar2d class Pulsar2d ( / , * args , ** kwargs ) Pulsar synthesis with a 2d wavetable & window stack Class variables amp burst channels freq mask pulsewidth samplerate Methods play def play ( ... )","title":"Pulsar2D"},{"location":"reference/pippi/pulsar2d/#module-pippipulsar2d","text":"","title":"Module pippi.pulsar2d"},{"location":"reference/pippi/pulsar2d/#classes","text":"","title":"Classes"},{"location":"reference/pippi/pulsar2d/#pulsar2d","text":"class Pulsar2d ( / , * args , ** kwargs ) Pulsar synthesis with a 2d wavetable & window stack","title":"Pulsar2d"},{"location":"reference/pippi/pulsar2d/#class-variables","text":"amp burst channels freq mask pulsewidth samplerate","title":"Class variables"},{"location":"reference/pippi/pulsar2d/#methods","text":"","title":"Methods"},{"location":"reference/pippi/pulsar2d/#play","text":"def play ( ... )","title":"play"},{"location":"reference/pippi/rand/","text":"Module pippi.rand Functions choice def choice ( ... ) rand def rand ( ... ) randint def randint ( ... ) seed def seed ( ... )","title":"Rand"},{"location":"reference/pippi/rand/#module-pippirand","text":"","title":"Module pippi.rand"},{"location":"reference/pippi/rand/#functions","text":"","title":"Functions"},{"location":"reference/pippi/rand/#choice","text":"def choice ( ... )","title":"choice"},{"location":"reference/pippi/rand/#rand","text":"def rand ( ... )","title":"rand"},{"location":"reference/pippi/rand/#randint","text":"def randint ( ... )","title":"randint"},{"location":"reference/pippi/rand/#seed","text":"def seed ( ... )","title":"seed"},{"location":"reference/pippi/rhythm/","text":"Module pippi.rhythm Some helpers for building and transforming onset lists Variables CLAVE REST_SYMBOLS Functions curve def curve ( ... ) eu def eu ( ... ) A euclidian pattern generator Length 6, numbeats 3 rhythm.eu(6, 3) [1, 0, 1, 0, 1, 0] Length 6, numbeats 3, offset 1 rhythm.eu(6, 3, 1) [0, 1, 0, 1, 0, 1] normalize_pattern def normalize_pattern ( ... ) onsets def onsets ( ... ) onsetswing def onsetswing ( ... ) Add MPC-style swing to a list of onsets. Amount is a value between 0 and 1, which maps to a swing amount between 0% and 75%. Every odd onset will be delayed by beat length * swing amount This will only really work like MPC swing when there is a run of notes, as rests are not represented in onset lists (and MPC swing just delays the upbeats). pattern def pattern ( ... ) Onsets from ascii pgen def pgen ( ... ) Pattern creation helper render def render ( ... ) repeat def repeat ( ... ) Repeat a sequence of onsets a given number of times rotate def rotate ( ... ) Rotate a pattern list by a given offset topositions def topositions ( ... )","title":"Rhythm"},{"location":"reference/pippi/rhythm/#module-pippirhythm","text":"Some helpers for building and transforming onset lists","title":"Module pippi.rhythm"},{"location":"reference/pippi/rhythm/#variables","text":"CLAVE REST_SYMBOLS","title":"Variables"},{"location":"reference/pippi/rhythm/#functions","text":"","title":"Functions"},{"location":"reference/pippi/rhythm/#curve","text":"def curve ( ... )","title":"curve"},{"location":"reference/pippi/rhythm/#eu","text":"def eu ( ... ) A euclidian pattern generator Length 6, numbeats 3 rhythm.eu(6, 3) [1, 0, 1, 0, 1, 0] Length 6, numbeats 3, offset 1 rhythm.eu(6, 3, 1) [0, 1, 0, 1, 0, 1]","title":"eu"},{"location":"reference/pippi/rhythm/#normalize_pattern","text":"def normalize_pattern ( ... )","title":"normalize_pattern"},{"location":"reference/pippi/rhythm/#onsets","text":"def onsets ( ... )","title":"onsets"},{"location":"reference/pippi/rhythm/#onsetswing","text":"def onsetswing ( ... ) Add MPC-style swing to a list of onsets. Amount is a value between 0 and 1, which maps to a swing amount between 0% and 75%. Every odd onset will be delayed by beat length * swing amount This will only really work like MPC swing when there is a run of notes, as rests are not represented in onset lists (and MPC swing just delays the upbeats).","title":"onsetswing"},{"location":"reference/pippi/rhythm/#pattern","text":"def pattern ( ... ) Onsets from ascii","title":"pattern"},{"location":"reference/pippi/rhythm/#pgen","text":"def pgen ( ... ) Pattern creation helper","title":"pgen"},{"location":"reference/pippi/rhythm/#render","text":"def render ( ... )","title":"render"},{"location":"reference/pippi/rhythm/#repeat","text":"def repeat ( ... ) Repeat a sequence of onsets a given number of times","title":"repeat"},{"location":"reference/pippi/rhythm/#rotate","text":"def rotate ( ... ) Rotate a pattern list by a given offset","title":"rotate"},{"location":"reference/pippi/rhythm/#topositions","text":"def topositions ( ... )","title":"topositions"},{"location":"reference/pippi/sampler/","text":"Module pippi.sampler Classes Sampler class Sampler ( / , * args , ** kwargs ) Methods getsnd def getsnd ( ... ) play def play ( ... )","title":"Sampler"},{"location":"reference/pippi/sampler/#module-pippisampler","text":"","title":"Module pippi.sampler"},{"location":"reference/pippi/sampler/#classes","text":"","title":"Classes"},{"location":"reference/pippi/sampler/#sampler","text":"class Sampler ( / , * args , ** kwargs )","title":"Sampler"},{"location":"reference/pippi/sampler/#methods","text":"","title":"Methods"},{"location":"reference/pippi/sampler/#getsnd","text":"def getsnd ( ... )","title":"getsnd"},{"location":"reference/pippi/sampler/#play","text":"def play ( ... )","title":"play"},{"location":"reference/pippi/shapes/","text":"Module pippi.shapes Variables MAX_SYNTH_FREQ MAX_WT_FREQ MIN_SYNTH_FREQ MIN_WT_FREQ Functions onsets def onsets ( ... ) synth def synth ( ... ) win def win ( ... ) wt def wt ( ... )","title":"Shapes"},{"location":"reference/pippi/shapes/#module-pippishapes","text":"","title":"Module pippi.shapes"},{"location":"reference/pippi/shapes/#variables","text":"MAX_SYNTH_FREQ MAX_WT_FREQ MIN_SYNTH_FREQ MIN_WT_FREQ","title":"Variables"},{"location":"reference/pippi/shapes/#functions","text":"","title":"Functions"},{"location":"reference/pippi/shapes/#onsets","text":"def onsets ( ... )","title":"onsets"},{"location":"reference/pippi/shapes/#synth","text":"def synth ( ... )","title":"synth"},{"location":"reference/pippi/shapes/#win","text":"def win ( ... )","title":"win"},{"location":"reference/pippi/shapes/#wt","text":"def wt ( ... )","title":"wt"},{"location":"reference/pippi/soundbuffer/","text":"Module pippi.soundbuffer Functions rebuild_buffer def rebuild_buffer ( ... ) Classes SoundBuffer class SoundBuffer ( / , * args , ** kwargs ) A sequence of audio frames representing a buffer of sound. Class variables avg channels dur frames mag samplerate Methods adsr def adsr ( ... ) clear def clear ( ... ) Writes zeros into the buffer, adjusting the size if length > 0. clip def clip ( ... ) cloud def cloud ( ... ) Create a new Cloud from this SoundBuffer convolve def convolve ( ... ) copy def copy ( ... ) Return a new copy of this SoundBuffer. cut def cut ( ... ) Copy a portion of this soundbuffer, returning a new soundbuffer with the selected slice. This is called cut for historical reasons, but it might be better understood if renamed to slice as it doesn't modify the source SoundBuffer in any way. The start param is a position in seconds to begin cutting, and the length param is the cut length in seconds. Overflowing values that exceed the boundries of the source SoundBuffer will return a SoundBuffer padded with silence so that the length param is always respected. dub def dub ( ... ) Dub a sound or iterable of sounds into this soundbuffer starting at the given position in fractional seconds. snd.dub(snd2, 3.2) To dub starting at a specific frame position use: snd.dub(snd3, framepos=111) env def env ( ... ) Apply an amplitude envelope to the sound of the given type. To modulate a sound with an arbitrary iterable, simply do: snd * iterable Where iterable is a list, array, or SoundBuffer with the same # of channels and of any length fill def fill ( ... ) Truncate the buffer to the given length or loop the contents of the buffer up to the given length in frames. grains def grains ( ... ) Iterate over the buffer in fixed-size grains. If a second length is given, iterate in randomly-sized grains, given the minimum and maximum sizes. graph def graph ( ... ) max def max ( ... ) mix def mix ( ... ) Mix this sound in place with a sound or iterable of sounds pad def pad ( ... ) Pad this sound with silence at start or end pan def pan ( ... ) Pan a stereo sound from pos=0 (hard left) to pos=1 (hard right) Different panning strategies can be chosen by passing a value to the method param. method='constant' Constant (square) power panning. This is the default. method='linear' Simple linear panning. method='sine' Variation on constant power panning using sin() and cos() to shape the pan. Taken from the floss manuals csound manual. method='gogins' Also taken from the csound manual -- Michael Gogins' variation on the above which uses a different part of the sinewave. rcut def rcut ( ... ) Copy a portion of this SoundBuffer of the given length in seconds starting from a random position within it. This will always return a complete SoundBuffer without overflows or added silence, and the entire sound will be returned without added silence if a length that exceeds the length of the source SoundBuffer is given -- unlike SoundBuffer.cut() which will pad results with silence to preserve the length param if an invalid or overflowing offset position is given. remix def remix ( ... ) repeat def repeat ( ... ) reverse def reverse ( ... ) reversed def reversed ( ... ) speed def speed ( ... ) Change the speed of the sound stretch def stretch ( ... ) Change the length of the sound without changing the pitch. Uses the csound mincer phase vocoder implementation from soundpipe. taper def taper ( ... ) toenv def toenv ( ... ) towavetable def towavetable ( ... ) transpose def transpose ( ... ) Change the pitch of the sound without changing the length. Uses the csound mincer phase vocoder implementation from soundpipe. TODO accept: from/to hz, notes, midi notes, intervals vspeed def vspeed ( ... ) write def write ( ... ) Write the contents of this buffer to disk in the given audio file format. (WAV, AIFF, AU)","title":"Soundbuffer"},{"location":"reference/pippi/soundbuffer/#module-pippisoundbuffer","text":"","title":"Module pippi.soundbuffer"},{"location":"reference/pippi/soundbuffer/#functions","text":"","title":"Functions"},{"location":"reference/pippi/soundbuffer/#rebuild_buffer","text":"def rebuild_buffer ( ... )","title":"rebuild_buffer"},{"location":"reference/pippi/soundbuffer/#classes","text":"","title":"Classes"},{"location":"reference/pippi/soundbuffer/#soundbuffer","text":"class SoundBuffer ( / , * args , ** kwargs ) A sequence of audio frames representing a buffer of sound.","title":"SoundBuffer"},{"location":"reference/pippi/soundbuffer/#class-variables","text":"avg channels dur frames mag samplerate","title":"Class variables"},{"location":"reference/pippi/soundbuffer/#methods","text":"","title":"Methods"},{"location":"reference/pippi/soundbuffer/#adsr","text":"def adsr ( ... )","title":"adsr"},{"location":"reference/pippi/soundbuffer/#clear","text":"def clear ( ... ) Writes zeros into the buffer, adjusting the size if length > 0.","title":"clear"},{"location":"reference/pippi/soundbuffer/#clip","text":"def clip ( ... )","title":"clip"},{"location":"reference/pippi/soundbuffer/#cloud","text":"def cloud ( ... ) Create a new Cloud from this SoundBuffer","title":"cloud"},{"location":"reference/pippi/soundbuffer/#convolve","text":"def convolve ( ... )","title":"convolve"},{"location":"reference/pippi/soundbuffer/#copy","text":"def copy ( ... ) Return a new copy of this SoundBuffer.","title":"copy"},{"location":"reference/pippi/soundbuffer/#cut","text":"def cut ( ... ) Copy a portion of this soundbuffer, returning a new soundbuffer with the selected slice. This is called cut for historical reasons, but it might be better understood if renamed to slice as it doesn't modify the source SoundBuffer in any way. The start param is a position in seconds to begin cutting, and the length param is the cut length in seconds. Overflowing values that exceed the boundries of the source SoundBuffer will return a SoundBuffer padded with silence so that the length param is always respected.","title":"cut"},{"location":"reference/pippi/soundbuffer/#dub","text":"def dub ( ... ) Dub a sound or iterable of sounds into this soundbuffer starting at the given position in fractional seconds. snd.dub(snd2, 3.2) To dub starting at a specific frame position use: snd.dub(snd3, framepos=111)","title":"dub"},{"location":"reference/pippi/soundbuffer/#env","text":"def env ( ... ) Apply an amplitude envelope to the sound of the given type. To modulate a sound with an arbitrary iterable, simply do: snd * iterable Where iterable is a list, array, or SoundBuffer with the same # of channels and of any length","title":"env"},{"location":"reference/pippi/soundbuffer/#fill","text":"def fill ( ... ) Truncate the buffer to the given length or loop the contents of the buffer up to the given length in frames.","title":"fill"},{"location":"reference/pippi/soundbuffer/#grains","text":"def grains ( ... ) Iterate over the buffer in fixed-size grains. If a second length is given, iterate in randomly-sized grains, given the minimum and maximum sizes.","title":"grains"},{"location":"reference/pippi/soundbuffer/#graph","text":"def graph ( ... )","title":"graph"},{"location":"reference/pippi/soundbuffer/#max","text":"def max ( ... )","title":"max"},{"location":"reference/pippi/soundbuffer/#mix","text":"def mix ( ... ) Mix this sound in place with a sound or iterable of sounds","title":"mix"},{"location":"reference/pippi/soundbuffer/#pad","text":"def pad ( ... ) Pad this sound with silence at start or end","title":"pad"},{"location":"reference/pippi/soundbuffer/#pan","text":"def pan ( ... ) Pan a stereo sound from pos=0 (hard left) to pos=1 (hard right) Different panning strategies can be chosen by passing a value to the method param. method='constant' Constant (square) power panning. This is the default. method='linear' Simple linear panning. method='sine' Variation on constant power panning using sin() and cos() to shape the pan. Taken from the floss manuals csound manual. method='gogins' Also taken from the csound manual -- Michael Gogins' variation on the above which uses a different part of the sinewave.","title":"pan"},{"location":"reference/pippi/soundbuffer/#rcut","text":"def rcut ( ... ) Copy a portion of this SoundBuffer of the given length in seconds starting from a random position within it. This will always return a complete SoundBuffer without overflows or added silence, and the entire sound will be returned without added silence if a length that exceeds the length of the source SoundBuffer is given -- unlike SoundBuffer.cut() which will pad results with silence to preserve the length param if an invalid or overflowing offset position is given.","title":"rcut"},{"location":"reference/pippi/soundbuffer/#remix","text":"def remix ( ... )","title":"remix"},{"location":"reference/pippi/soundbuffer/#repeat","text":"def repeat ( ... )","title":"repeat"},{"location":"reference/pippi/soundbuffer/#reverse","text":"def reverse ( ... )","title":"reverse"},{"location":"reference/pippi/soundbuffer/#reversed","text":"def reversed ( ... )","title":"reversed"},{"location":"reference/pippi/soundbuffer/#speed","text":"def speed ( ... ) Change the speed of the sound","title":"speed"},{"location":"reference/pippi/soundbuffer/#stretch","text":"def stretch ( ... ) Change the length of the sound without changing the pitch. Uses the csound mincer phase vocoder implementation from soundpipe.","title":"stretch"},{"location":"reference/pippi/soundbuffer/#taper","text":"def taper ( ... )","title":"taper"},{"location":"reference/pippi/soundbuffer/#toenv","text":"def toenv ( ... )","title":"toenv"},{"location":"reference/pippi/soundbuffer/#towavetable","text":"def towavetable ( ... )","title":"towavetable"},{"location":"reference/pippi/soundbuffer/#transpose","text":"def transpose ( ... ) Change the pitch of the sound without changing the length. Uses the csound mincer phase vocoder implementation from soundpipe. TODO accept: from/to hz, notes, midi notes, intervals","title":"transpose"},{"location":"reference/pippi/soundbuffer/#vspeed","text":"def vspeed ( ... )","title":"vspeed"},{"location":"reference/pippi/soundbuffer/#write","text":"def write ( ... ) Write the contents of this buffer to disk in the given audio file format. (WAV, AIFF, AU)","title":"write"},{"location":"reference/pippi/soundfont/","text":"Module pippi.soundfont Variables BLOCKSIZE CHANNELS NOTE_OFF NOTE_ON SAMPLERATE Functions play def play ( ... ) playall def playall ( ... )","title":"Soundfont"},{"location":"reference/pippi/soundfont/#module-pippisoundfont","text":"","title":"Module pippi.soundfont"},{"location":"reference/pippi/soundfont/#variables","text":"BLOCKSIZE CHANNELS NOTE_OFF NOTE_ON SAMPLERATE","title":"Variables"},{"location":"reference/pippi/soundfont/#functions","text":"","title":"Functions"},{"location":"reference/pippi/soundfont/#play","text":"def play ( ... )","title":"play"},{"location":"reference/pippi/soundfont/#playall","text":"def playall ( ... )","title":"playall"},{"location":"reference/pippi/soundpipe/","text":"Module pippi.soundpipe Functions bitcrush def bitcrush ( ... ) butbp def butbp ( ... ) butbr def butbr ( ... ) buthp def buthp ( ... ) butlp def butlp ( ... ) compressor def compressor ( ... ) dcblock def dcblock ( ... ) mincer def mincer ( ... ) paulstretch def paulstretch ( ... ) saturator def saturator ( ... )","title":"Soundpipe"},{"location":"reference/pippi/soundpipe/#module-pippisoundpipe","text":"","title":"Module pippi.soundpipe"},{"location":"reference/pippi/soundpipe/#functions","text":"","title":"Functions"},{"location":"reference/pippi/soundpipe/#bitcrush","text":"def bitcrush ( ... )","title":"bitcrush"},{"location":"reference/pippi/soundpipe/#butbp","text":"def butbp ( ... )","title":"butbp"},{"location":"reference/pippi/soundpipe/#butbr","text":"def butbr ( ... )","title":"butbr"},{"location":"reference/pippi/soundpipe/#buthp","text":"def buthp ( ... )","title":"buthp"},{"location":"reference/pippi/soundpipe/#butlp","text":"def butlp ( ... )","title":"butlp"},{"location":"reference/pippi/soundpipe/#compressor","text":"def compressor ( ... )","title":"compressor"},{"location":"reference/pippi/soundpipe/#dcblock","text":"def dcblock ( ... )","title":"dcblock"},{"location":"reference/pippi/soundpipe/#mincer","text":"def mincer ( ... )","title":"mincer"},{"location":"reference/pippi/soundpipe/#paulstretch","text":"def paulstretch ( ... )","title":"paulstretch"},{"location":"reference/pippi/soundpipe/#saturator","text":"def saturator ( ... )","title":"saturator"},{"location":"reference/pippi/tukey/","text":"Module pippi.tukey Classes Tukey class Tukey ( / , * args , ** kwargs ) Class variables channels samplerate Methods play def play ( ... )","title":"Tukey"},{"location":"reference/pippi/tukey/#module-pippitukey","text":"","title":"Module pippi.tukey"},{"location":"reference/pippi/tukey/#classes","text":"","title":"Classes"},{"location":"reference/pippi/tukey/#tukey","text":"class Tukey ( / , * args , ** kwargs )","title":"Tukey"},{"location":"reference/pippi/tukey/#class-variables","text":"channels samplerate","title":"Class variables"},{"location":"reference/pippi/tukey/#methods","text":"","title":"Methods"},{"location":"reference/pippi/tukey/#play","text":"def play ( ... )","title":"play"},{"location":"reference/pippi/wavesets/","text":"Module pippi.wavesets Classes Waveset class Waveset ( / , * args , ** kwargs ) Class variables max_length min_length samplerate wavesets Methods copy def copy ( ... ) harmonic def harmonic ( ... ) interleave def interleave ( ... ) invert def invert ( ... ) morph def morph ( ... ) normalize def normalize ( ... ) render def render ( ... ) replace def replace ( ... ) retrograde def retrograde ( ... ) reverse def reverse ( ... ) reversed def reversed ( ... ) stretch def stretch ( ... ) substitute def substitute ( ... )","title":"Wavesets"},{"location":"reference/pippi/wavesets/#module-pippiwavesets","text":"","title":"Module pippi.wavesets"},{"location":"reference/pippi/wavesets/#classes","text":"","title":"Classes"},{"location":"reference/pippi/wavesets/#waveset","text":"class Waveset ( / , * args , ** kwargs )","title":"Waveset"},{"location":"reference/pippi/wavesets/#class-variables","text":"max_length min_length samplerate wavesets","title":"Class variables"},{"location":"reference/pippi/wavesets/#methods","text":"","title":"Methods"},{"location":"reference/pippi/wavesets/#copy","text":"def copy ( ... )","title":"copy"},{"location":"reference/pippi/wavesets/#harmonic","text":"def harmonic ( ... )","title":"harmonic"},{"location":"reference/pippi/wavesets/#interleave","text":"def interleave ( ... )","title":"interleave"},{"location":"reference/pippi/wavesets/#invert","text":"def invert ( ... )","title":"invert"},{"location":"reference/pippi/wavesets/#morph","text":"def morph ( ... )","title":"morph"},{"location":"reference/pippi/wavesets/#normalize","text":"def normalize ( ... )","title":"normalize"},{"location":"reference/pippi/wavesets/#render","text":"def render ( ... )","title":"render"},{"location":"reference/pippi/wavesets/#replace","text":"def replace ( ... )","title":"replace"},{"location":"reference/pippi/wavesets/#retrograde","text":"def retrograde ( ... )","title":"retrograde"},{"location":"reference/pippi/wavesets/#reverse","text":"def reverse ( ... )","title":"reverse"},{"location":"reference/pippi/wavesets/#reversed","text":"def reversed ( ... )","title":"reversed"},{"location":"reference/pippi/wavesets/#stretch","text":"def stretch ( ... )","title":"stretch"},{"location":"reference/pippi/wavesets/#substitute","text":"def substitute ( ... )","title":"substitute"},{"location":"reference/pippi/wavetables/","text":"Module pippi.wavetables Variables SEGMENT_RE Functions adsr def adsr ( ... ) fromfile def fromfile ( ... ) polyseg def polyseg ( ... ) Calculate total output segment length in frames & alloc outbuf loop thru segments: - generate segment - write segment into outbuf for each segment: - calc the true length of the individual segment based on segment length - scale the size of the tmp segment to match remainder after start/end filtering - produce a tmp array from the waveform type (using normal wavetable or window generator) - copy into outbuf segment crossfading? seesaw def seesaw ( ... ) to_stack def to_stack ( ... ) to_wavetable def to_wavetable ( ... ) to_window def to_window ( ... ) wavetable def wavetable ( ... ) Classes Wavetable class Wavetable ( / , * args , ** kwargs ) Class variables data highvalue length lowvalue Methods clip def clip ( ... ) convolve def convolve ( ... ) crush def crush ( ... ) crushed def crushed ( ... ) cut def cut ( ... ) drink def drink ( ... ) env def env ( ... ) graph def graph ( ... ) harmonics def harmonics ( ... ) interp def interp ( ... ) leftpad def leftpad ( ... ) leftpadded def leftpadded ( ... ) max def max ( ... ) normalize def normalize ( ... ) pad def pad ( ... ) padded def padded ( ... ) rcut def rcut ( ... ) repeat def repeat ( ... ) repeated def repeated ( ... ) reverse def reverse ( ... ) reversed def reversed ( ... ) rightpad def rightpad ( ... ) rightpadded def rightpadded ( ... ) scale def scale ( ... ) scaled def scaled ( ... ) skew def skew ( ... ) skewed def skewed ( ... ) snap def snap ( ... ) snapped def snapped ( ... ) taper def taper ( ... ) toonsets def toonsets ( ... ) write def write ( ... )","title":"Wavetables"},{"location":"reference/pippi/wavetables/#module-pippiwavetables","text":"","title":"Module pippi.wavetables"},{"location":"reference/pippi/wavetables/#variables","text":"SEGMENT_RE","title":"Variables"},{"location":"reference/pippi/wavetables/#functions","text":"","title":"Functions"},{"location":"reference/pippi/wavetables/#adsr","text":"def adsr ( ... )","title":"adsr"},{"location":"reference/pippi/wavetables/#fromfile","text":"def fromfile ( ... )","title":"fromfile"},{"location":"reference/pippi/wavetables/#polyseg","text":"def polyseg ( ... ) Calculate total output segment length in frames & alloc outbuf loop thru segments: - generate segment - write segment into outbuf for each segment: - calc the true length of the individual segment based on segment length - scale the size of the tmp segment to match remainder after start/end filtering - produce a tmp array from the waveform type (using normal wavetable or window generator) - copy into outbuf segment crossfading?","title":"polyseg"},{"location":"reference/pippi/wavetables/#seesaw","text":"def seesaw ( ... )","title":"seesaw"},{"location":"reference/pippi/wavetables/#to_stack","text":"def to_stack ( ... )","title":"to_stack"},{"location":"reference/pippi/wavetables/#to_wavetable","text":"def to_wavetable ( ... )","title":"to_wavetable"},{"location":"reference/pippi/wavetables/#to_window","text":"def to_window ( ... )","title":"to_window"},{"location":"reference/pippi/wavetables/#wavetable","text":"def wavetable ( ... )","title":"wavetable"},{"location":"reference/pippi/wavetables/#classes","text":"","title":"Classes"},{"location":"reference/pippi/wavetables/#wavetable_1","text":"class Wavetable ( / , * args , ** kwargs )","title":"Wavetable"},{"location":"reference/pippi/wavetables/#class-variables","text":"data highvalue length lowvalue","title":"Class variables"},{"location":"reference/pippi/wavetables/#methods","text":"","title":"Methods"},{"location":"reference/pippi/wavetables/#clip","text":"def clip ( ... )","title":"clip"},{"location":"reference/pippi/wavetables/#convolve","text":"def convolve ( ... )","title":"convolve"},{"location":"reference/pippi/wavetables/#crush","text":"def crush ( ... )","title":"crush"},{"location":"reference/pippi/wavetables/#crushed","text":"def crushed ( ... )","title":"crushed"},{"location":"reference/pippi/wavetables/#cut","text":"def cut ( ... )","title":"cut"},{"location":"reference/pippi/wavetables/#drink","text":"def drink ( ... )","title":"drink"},{"location":"reference/pippi/wavetables/#env","text":"def env ( ... )","title":"env"},{"location":"reference/pippi/wavetables/#graph","text":"def graph ( ... )","title":"graph"},{"location":"reference/pippi/wavetables/#harmonics","text":"def harmonics ( ... )","title":"harmonics"},{"location":"reference/pippi/wavetables/#interp","text":"def interp ( ... )","title":"interp"},{"location":"reference/pippi/wavetables/#leftpad","text":"def leftpad ( ... )","title":"leftpad"},{"location":"reference/pippi/wavetables/#leftpadded","text":"def leftpadded ( ... )","title":"leftpadded"},{"location":"reference/pippi/wavetables/#max","text":"def max ( ... )","title":"max"},{"location":"reference/pippi/wavetables/#normalize","text":"def normalize ( ... )","title":"normalize"},{"location":"reference/pippi/wavetables/#pad","text":"def pad ( ... )","title":"pad"},{"location":"reference/pippi/wavetables/#padded","text":"def padded ( ... )","title":"padded"},{"location":"reference/pippi/wavetables/#rcut","text":"def rcut ( ... )","title":"rcut"},{"location":"reference/pippi/wavetables/#repeat","text":"def repeat ( ... )","title":"repeat"},{"location":"reference/pippi/wavetables/#repeated","text":"def repeated ( ... )","title":"repeated"},{"location":"reference/pippi/wavetables/#reverse","text":"def reverse ( ... )","title":"reverse"},{"location":"reference/pippi/wavetables/#reversed","text":"def reversed ( ... )","title":"reversed"},{"location":"reference/pippi/wavetables/#rightpad","text":"def rightpad ( ... )","title":"rightpad"},{"location":"reference/pippi/wavetables/#rightpadded","text":"def rightpadded ( ... )","title":"rightpadded"},{"location":"reference/pippi/wavetables/#scale","text":"def scale ( ... )","title":"scale"},{"location":"reference/pippi/wavetables/#scaled","text":"def scaled ( ... )","title":"scaled"},{"location":"reference/pippi/wavetables/#skew","text":"def skew ( ... )","title":"skew"},{"location":"reference/pippi/wavetables/#skewed","text":"def skewed ( ... )","title":"skewed"},{"location":"reference/pippi/wavetables/#snap","text":"def snap ( ... )","title":"snap"},{"location":"reference/pippi/wavetables/#snapped","text":"def snapped ( ... )","title":"snapped"},{"location":"reference/pippi/wavetables/#taper","text":"def taper ( ... )","title":"taper"},{"location":"reference/pippi/wavetables/#toonsets","text":"def toonsets ( ... )","title":"toonsets"},{"location":"reference/pippi/wavetables/#write","text":"def write ( ... )","title":"write"},{"location":"reference/pippi/tune/","text":"Module pippi.tune View Source import re import math import random a0 = 27.5 a4 = a0 * 2 ** 4 default_key = 'c' match_roman = '[ivIV]?[ivIV]?[iI]?' INTERVALS = { 'P1' : 0 , 'm2' : 1 , 'M2' : 2 , 'm3' : 3 , 'M3' : 4 , 'P4' : 5 , 'TT' : 6 , 'P5' : 7 , 'm6' : 8 , 'M6' : 9 , 'm7' : 10 , 'M7' : 11 , 'P8' : 12 , 'm9' : 13 , 'M9' : 14 , 'm10' : 15 , 'M10' : 16 , 'P11' : 17 , 'd12' : 18 , # TT + P8 'P12' : 19 , 'm13' : 20 , 'M13' : 21 , 'm14' : 22 , 'M14' : 23 , 'P15' : 24 } # what's the best way to handle inversions? BASE_QUALITIES = { '^' : [ 'P1' , 'M3' , 'P5' ], # major '-' : [ 'P1' , 'm3' , 'P5' ], # minor '*' : [ 'P1' , 'm3' , 'TT' ], # diminished '+' : [ 'P1' , 'M3' , 'm6' ], # augmented } EXTENSIONS = { '7' : [ 'm7' ], # dominant 7th '^7' : [ 'M7' ], # major 7th '9' : [ 'm7' , 'M9' ], # dominant 9th '^9' : [ 'M7' , 'M9' ], # major 9th '11' : [ 'm7' , 'M9' , 'P11' ], # dominant 11th '^11' : [ 'M7' , 'M9' , 'P11' ], '69' : [ 'M6' , 'M9' ], # dominant 6/9 '6' : [ 'M6' ], } CHORD_ROMANS = { 'i' : 0 , 'ii' : 2 , 'iii' : 4 , 'iv' : 5 , 'v' : 7 , 'vi' : 9 , 'vii' : 11 , } # Common root movements PROGRESSIONS = { 'I' : [ 'iii' , 'vi' , 'ii' , 'IV' , 'V' , 'vii*' ], 'i' : [ 'VII' , 'III' , 'VI' , 'ii*' , 'iv' , 'V' , 'vii*' ], 'ii' : [ 'V' , 'vii*' ], 'iii' : [ 'vi' ], 'III' : [ 'VI' ], 'IV' : [ 'V' , 'vii*' ], 'iv' : [ 'V' , 'vii*' ], 'V' : [ 'I' , 'i' ], # a pivot 'v' : [ 'I' , 'i' ], # a pivot 'vi' : [ 'ii' , 'IV' ], 'VI' : [ 'ii*' , 'iv' ], 'vii*' : [ 'I' , 'i' ], # a pivot 'vii' : [ 'I' , 'i' ], # a pivot } EQUAL = tuple ([ 2 ** ( i / 12 ) for i in range ( 12 ) ]) JUST = ( ( 1.0 , 1.0 ), # P1 ( 16.0 , 15.0 ), # m2 ( 9.0 , 8.0 ), # M2 ( 6.0 , 5.0 ), # m3 ( 5.0 , 4.0 ), # M3 ( 4.0 , 3.0 ), # P4 ( 45.0 , 32.0 ), # TT ( 3.0 , 2.0 ), # P5 ( 8.0 , 5.0 ), # m6 ( 5.0 , 3.0 ), # M6 ( 9.0 , 5.0 ), # m7 ( 15.0 , 8.0 ), # M7 ) TERRY = ( ( 1.0 , 1.0 ), # P1 C ( 16.0 , 15.0 ), # m2 Db ( 10.0 , 9.0 ), # M2 D ( 6.0 , 5.0 ), # m3 Eb ( 5.0 , 4.0 ), # M3 E ( 4.0 , 3.0 ), # P4 F ( 64.0 , 45.0 ), # TT Gb ( 3.0 , 2.0 ), # P5 G ( 8.0 , 5.0 ), # m6 Ab ( 27.0 , 16.0 ), # M6 A ( 16.0 , 9.0 ), # m7 Bb ( 15.0 , 8.0 ), # M7 B ) YOUNG = ( ( 1.0 , 1.0 ), # P1 0 ( 567.0 , 512.0 ), # m2 1 ( 9.0 , 8.0 ), # M2 2 ( 147.0 , 128.0 ), # m3 3 ( 21.0 , 16.0 ), # M3 4 ( 1323.0 , 1024.0 ), # P4 5 ( 189.0 , 128.0 ), # TT 6 ( 3.0 , 2.0 ), # P5 7 ( 49.0 , 32.0 ), # m6 8 ( 7.0 , 4.0 ), # M6 9 ( 441.0 , 256.0 ), # m7 10 ( 63.0 , 32.0 ), # M7 11 ) LOUIS = ( ( 1 , 1 ), ( math . sqrt ( 5 ) * 0.5 , 1 ), ( math . sqrt ( 6 ) * 0.5 , 1 ), ( math . sqrt ( 7 ) * 0.5 , 1 ), ( math . sqrt ( 2 ), 1 ), ( math . sqrt ( 9 ) * 0.5 , 1 ), ( math . sqrt ( 10 ) * 0.5 , 1 ), ( math . sqrt ( 11 ) * 0.5 , 1 ), ( math . sqrt ( 3 ), 1 ), ( math . sqrt ( 13 ) * 0.5 , 1 ), ( math . sqrt ( 14 ) * 0.5 , 1 ), ( math . sqrt ( 15 ) * 0.5 , 1 ), ) ## scale mappings # standard MAJOR = ( 0 , 2 , 4 , 5 , 7 , 9 , 11 ) MINOR = ( 0 , 2 , 3 , 5 , 7 , 8 , 10 ) CHROMATIC = tuple ( range ( 12 )) # notated as semitone deviations from # a MAJOR scale for readability SCALES = { 'MAJOR' : MAJOR , 'MINOR' : MINOR , 'super_locrian' : ( 0 , 2 - 1 , 4 - 1 , 5 - 1 , 7 - 1 , 9 - 1 , 11 - 1 ), 'neapolitan_minor' : ( 0 , 2 - 1 , 4 - 1 , 5 , 7 , 9 - 1 , 11 ), 'neapolitan_major' : ( 0 , 2 - 1 , 4 - 1 , 5 , 7 , 9 , 11 ), 'oriental' : ( 0 , 2 - 1 , 4 , 5 , 7 - 1 , 9 , 11 - 1 ), 'double_harmonic' : ( 0 , 2 - 1 , 4 , 5 , 7 , 9 - 1 , 11 ), 'enigmatic' : ( 0 , 2 - 1 , 4 , 5 + 1 , 7 + 1 , 9 + 1 , 11 ), } # Maps to CHROMATIC ratio lists above NOTES = { 'a' : 0 , 'a#' : 1 , 'bb' : 1 , 'b' : 2 , 'c' : 3 , 'c#' : 4 , 'db' : 4 , 'd' : 5 , 'd#' : 6 , 'eb' : 6 , 'e' : 7 , 'f' : 8 , 'f#' : 9 , 'gb' : 9 , 'g' : 10 , 'g#' : 11 , 'ab' : 11 , } MIDI_NOTES = { 'a' : 21 , 'a#' : 22 , 'bb' : 22 , 'b' : 23 , 'c' : 24 , 'c#' : 25 , 'db' : 25 , 'd' : 26 , 'd#' : 27 , 'eb' : 27 , 'e' : 28 , 'f' : 29 , 'f#' : 30 , 'gb' : 30 , 'g' : 31 , 'g#' : 32 , 'ab' : 32 , } def mtof ( midi_note ): return 2 ** (( midi_note - 69 ) / 12.0 ) * 440 def ftom ( freq ): return math . log ( freq / 440.0 , 2 ) * 12 + 69 def ftomi ( freq ): return int ( round ( ftom ( freq ))) def parse_pitch_class ( note , octave = None ): note = note . lower () if re . match ( '[a-zA-Z]#?b?\\d+' , note ) is not None : parsed = re . match ( '([a-zA-Z]#?b?)(\\d+)' , note ) note = parsed . group ( 1 ) octave = int ( parsed . group ( 2 )) if octave is None : octave = 4 return note , octave def ntm ( note , octave = None ): note , octave = parse_pitch_class ( note , octave ) note_index = nti ( note ) if note_index >= 3 : octave -= 1 return note_index + 21 + ( octave * 12 ) def edo ( degree , divs = 12 ): return 2 ** ( degree / float ( divs )) def edo_ratios ( divs = 12 ): return [ ( edo ( i , divs ), 1.0 ) for i in range ( 1 , divs + 1 ) ] def edo_scale ( divs = 12 ): return [ edo ( i , divs ) for i in range ( 1 , divs + 1 ) ] def nti ( note ): \"\"\" Note to index returns the index of enharmonic note names or False if not found \"\"\" return NOTES . get ( note , False ) def ntf ( note , octave = None , ratios = None ): \"\"\" Note to freq \"\"\" if ratios is None : ratios = TERRY note , octave = parse_pitch_class ( note , octave ) note_index = nti ( note ) mult = ratios [ note_index ][ 0 ] / ratios [ note_index ][ 1 ] if note_index >= 3 : octave -= 1 return mult * a0 * 2.0 ** octave def stf ( index ): degree = index % 24 octave = index / 24 return ( 2 ** ( degree / 24.0 )) * ( a0 / 4.0 ) * ( 2.0 ** octave ) def mtf ( midi_note ): return 2 ** (( midi_note - 69 ) / 12.0 ) * 440.0 def fts ( freq ): # Try to find closest eq temp freq to input # Generate entire range of possible eq temp freqs all_freq = [ stf ( index ) for index in range ( 2 ** 8 ) ] count = 0 cfreq = 0 while freq > cfreq and count < 2 ** 8 : cfreq = all_freq [ count ] count = count + 1 count = count - 1 return count % 55 def nts ( note , octave ): octave = octave if octave >= - 2 else - 2 octave = octave if octave <= 8 else 8 degree = NOTES [ note ] * 2 degree = degree + (( octave + 2 ) * 24 ) return degree def getmultiplier ( ratios , scale , degree ): base = scale [( degree - 1 ) % len ( scale )] octave = degree // ( len ( scale ) + 1 ) mult = ratios [ base ] if isinstance ( mult , tuple ): mult = mult [ 0 ] / mult [ 1 ] mult = mult * 2 ** octave return mult def int_to_byte_list ( val ): return list ( map ( int , list ( bin ( val ))[ 2 :])) def str_to_byte_list ( val ): return list ( map ( int , val )) def to_scale_mask ( mapping ): mask = [] if isinstance ( mapping , int ): mask = int_to_byte_list ( mapping ) elif isinstance ( mapping , bytes ): for i in list ( mapping ): mask += int_to_byte_list ( i ) elif isinstance ( mapping , str ): mask = str_to_byte_list ( mapping ) elif isinstance ( mapping , list ) or isinstance ( mapping , tuple ): mask = list ( map ( int , mapping )) else : raise NotImplemented return mask def scale_mask_to_indexes ( mask ): mask = to_scale_mask ( mask ) scale_indexes = [] for i , m in enumerate ( mask ): if m == 1 : scale_indexes += [ i ] return scale_indexes def tofreqs ( degrees = None , root = 261.63 , ratios = None , scale = None , scale_mask = None ): if ratios is None : ratios = JUST if scale is None : scale = MAJOR if degrees is None : degrees = range ( len ( scale )) if scale_mask is not None : scale = scale_mask_to_indexes ( scale_mask ) freqs = [] for degree in degrees : freq = root * getmultiplier ( ratios , scale , degree ) freqs += [ freq ] return freqs def fromdegrees ( scale_degrees = None , octave = 2 , root = 'c' , scale = None , ratios = None ): # TODO maybe depricate in favor of to_freqs() if scale_degrees is None : scale_degrees = [ 1 , 3 , 5 ] if ratios is None : ratios = TERRY if scale is None : scale = MAJOR freqs = [] root = ntf ( root , octave ) for index , degree in enumerate ( scale_degrees ): # strings are okay degree = int ( degree ) # register offset 0+ register = degree // ( len ( scale ) + 1 ) chromatic_degree = scale [( degree - 1 ) % len ( scale )] ratio = ratios [ chromatic_degree ] freqs += [ root * ( ratio [ 0 ] / ratio [ 1 ]) * 2 ** register ] return freqs def get_quality ( name ): quality = '-' if name . islower () else '^' quality = '*' if re . match ( match_roman + '[*]' , name ) is not None else quality return quality def get_extension ( name ): return re . sub ( match_roman + '[/*+]?' , '' , name ) def get_intervals ( name ): quality = get_quality ( name ) extension = get_extension ( name ) chord = BASE_QUALITIES [ quality ] if extension != '' : chord = chord + EXTENSIONS [ extension ] return chord def get_freq_from_chord_name ( name , root = 440 , octave = 3 , ratios = JUST ): index = get_chord_root_index ( name ) freq = ratios [ index ] freq = root * ( freq [ 0 ] / freq [ 1 ]) * 2 ** octave return freq def strip_chord ( name ): root = re . sub ( '[#b+/*^0-9]+' , '' , name ) return root . lower () def get_chord_root_index ( name ): root = CHORD_ROMANS [ strip_chord ( name )] if '#' in name : root += 1 if 'b' in name : root -= 1 return root % 12 def add_intervals ( a , b ): a = INTERVALS [ a ] b = INTERVALS [ b ] c = a + b for interval , index in INTERVALS . items (): if c == index : c = interval return c def get_ratio_from_interval ( interval , ratios ): try : index = INTERVALS [ interval ] except IndexError : log ( 'Interval out of range, doh. Here have a P1' ) index = 0 try : ratio = ratios [ index ] ratio = ratio [ 0 ] / ratio [ 1 ] except IndexError : base_index = index % 12 ratio = ratios [ base_index ] ratio = ratio [ 0 ] / ratio [ 1 ] register = ( index - base_index ) / 12 ratio *= 2 ** register return ratio def next_chord ( name ): name = strip_chord ( name ) return random . choice ( PROGRESSIONS [ name ]) def chord ( name , key = None , octave = 3 , ratios = None ): if key is None : key = default_key if ratios is None : ratios = TERRY key = ntf ( key , octave , ratios ) root = ratios [ get_chord_root_index ( name )] root = key * ( root [ 0 ] / root [ 1 ]) name = re . sub ( '[#b]+' , '' , name ) chord = get_intervals ( name ) chord = [ get_ratio_from_interval ( interval , ratios ) for interval in chord ] chord = [ root * ratio for ratio in chord ] return chord def chords ( names , key = None , octave = 3 , ratios = JUST ): if key is None : key = default_key return [ chord ( name , key , octave , ratios ) for name in names ] def fit_scale ( freq , scale ): # Thanks to @kennytm from stack overflow for this <3 <3 return min ( scale , key = lambda x : abs ( x - freq )) def fit ( freq , low = 20 , high = 20000 , get_change = False ): \"\"\" fit the given freq within the given freq range, by transposing up or down octaves \"\"\" # need to fit at least an octave if high < low * 2 : high = low * 2 def shift ( freq , low , high , octave_shift = 0 ): if freq < low : return shift ( freq * 2 , low , high , octave_shift + 1 ) if freq > high : return shift ( freq * 0.5 , low , high , octave_shift - 1 ) return freq , octave_shift freq , octave = shift ( freq , low , high ) if octave == 0 : mult = 1 elif octave > 0 : mult = 2 ** octave elif octave < 0 : mult = 1.0 / ( 2 ** abs ( octave )) if get_change == True : return freq , mult else : return freq class Parser : def __init__ ( self , score , durations = None , octave = 3 , ratios = None ): self . score = score self . octave = octave if durations is None : durations = ( 0.5 ,) self . durations = durations if ratios is None : ratios = TERRY self . ratios = ratios def parse ( self ): pos = 0 events = [] for note in self . score . split ( ' ' ): cluster = note . split ( ',' ) events += [( pos , cluster )] self . parsed = parsed Sub-modules pippi.tune.scala Variables BASE_QUALITIES CHORD_ROMANS CHROMATIC EQUAL EXTENSIONS INTERVALS JUST LOUIS MAJOR MIDI_NOTES MINOR NOTES PROGRESSIONS SCALES TERRY YOUNG a0 a4 default_key match_roman Functions add_intervals def add_intervals ( a , b ) View Source def add_intervals ( a , b ) : a = INTERVALS [ a ] b = INTERVALS [ b ] c = a + b for interval , index in INTERVALS . items () : if c == index : c = interval return c chord def chord ( name , key = None , octave = 3 , ratios = None ) View Source def chord ( name , key = None , octave = 3 , ratios = None ): if key is None : key = default_key if ratios is None : ratios = TERRY key = ntf ( key , octave , ratios ) root = ratios [ get_chord_root_index ( name )] root = key * ( root [ 0 ] / root [ 1 ]) name = re . sub ( '[#b]+' , '' , name ) chord = get_intervals ( name ) chord = [ get_ratio_from_interval ( interval , ratios ) for interval in chord ] chord = [ root * ratio for ratio in chord ] return chord chords def chords ( names , key = None , octave = 3 , ratios = (( 1.0 , 1.0 ), ( 16.0 , 15.0 ), ( 9.0 , 8.0 ), ( 6.0 , 5.0 ), ( 5.0 , 4.0 ), ( 4.0 , 3.0 ), ( 45.0 , 32.0 ), ( 3.0 , 2.0 ), ( 8.0 , 5.0 ), ( 5.0 , 3.0 ), ( 9.0 , 5.0 ), ( 15.0 , 8.0 )) ) View Source def chords ( names , key = None , octave = 3 , ratios = JUST ): if key is None : key = default_key return [ chord ( name , key , octave , ratios ) for name in names ] edo def edo ( degree , divs = 12 ) View Source def edo ( degree , divs = 12 ): return 2 ** ( degree / float ( divs )) edo_ratios def edo_ratios ( divs = 12 ) View Source def edo_ratios ( divs = 12 ): return [ ( edo ( i , divs ), 1 . 0 ) for i in range ( 1 , divs + 1 ) ] edo_scale def edo_scale ( divs = 12 ) View Source def edo_scale ( divs = 12 ): return [ edo ( i , divs ) for i in range ( 1 , divs + 1 ) ] fit def fit ( freq , low = 20 , high = 20000 , get_change = False ) fit the given freq within the given freq range, by transposing up or down octaves View Source def fit ( freq , low = 20 , high = 20000 , get_change = False ): \"\"\" fit the given freq within the given freq range, by transposing up or down octaves \"\"\" # need to fit at least an octave if high < low * 2 : high = low * 2 def shift ( freq , low , high , octave_shift = 0 ): if freq < low : return shift ( freq * 2 , low , high , octave_shift + 1 ) if freq > high : return shift ( freq * 0 . 5 , low , high , octave_shift - 1 ) return freq , octave_shift freq , octave = shift ( freq , low , high ) if octave == 0 : mult = 1 elif octave > 0 : mult = 2 ** octave elif octave < 0 : mult = 1 . 0 / ( 2 ** abs ( octave )) if get_change == True : return freq , mult else : return freq fit_scale def fit_scale ( freq , scale ) View Source def fit_scale ( freq , scale ) : # Thanks to @kennytm from stack overflow for this < 3 < 3 return min ( scale , key = lambda x : abs ( x - freq )) fromdegrees def fromdegrees ( scale_degrees = None , octave = 2 , root = 'c' , scale = None , ratios = None ) View Source def fromdegrees ( scale_degrees = None , octave = 2 , root = 'c' , scale = None , ratios = None ) : # TODO maybe depricate in favor of to_freqs () if scale_degrees is None : scale_degrees = [ 1,3,5 ] if ratios is None : ratios = TERRY if scale is None : scale = MAJOR freqs = [] root = ntf ( root , octave ) for index , degree in enumerate ( scale_degrees ) : # strings are okay degree = int ( degree ) # register offset 0 + register = degree // ( len ( scale ) + 1 ) chromatic_degree = scale [ (degree - 1) % len(scale) ] ratio = ratios [ chromatic_degree ] freqs += [ root * (ratio[0 ] / ratio [ 1 ] ) * 2 ** register ] return freqs ftom def ftom ( freq ) View Source def ftom ( freq ): return math . log ( freq / 440 . 0 , 2 ) * 12 + 69 ftomi def ftomi ( freq ) View Source def ftomi ( freq ): return int ( round ( ftom ( freq ))) fts def fts ( freq ) View Source def fts ( freq ) : # Try to find closest eq temp freq to input # Generate entire range of possible eq temp freqs all_freq = [ stf(index) for index in range(2**8) ] count = 0 cfreq = 0 while freq > cfreq and count < 2 ** 8 : cfreq = all_freq [ count ] count = count + 1 count = count - 1 return count % 55 get_chord_root_index def get_chord_root_index ( name ) View Source def get_chord_root_index ( name ): root = CHORD_ROMANS [ strip_chord ( name )] if '#' in name : root += 1 if 'b' in name : root -= 1 return root % 12 get_extension def get_extension ( name ) View Source def get_extension ( name ): return re . sub ( match_roman + '[/*+]?' , '' , name ) get_freq_from_chord_name def get_freq_from_chord_name ( name , root = 440 , octave = 3 , ratios = (( 1.0 , 1.0 ), ( 16.0 , 15.0 ), ( 9.0 , 8.0 ), ( 6.0 , 5.0 ), ( 5.0 , 4.0 ), ( 4.0 , 3.0 ), ( 45.0 , 32.0 ), ( 3.0 , 2.0 ), ( 8.0 , 5.0 ), ( 5.0 , 3.0 ), ( 9.0 , 5.0 ), ( 15.0 , 8.0 )) ) View Source def get_freq_from_chord_name ( name , root = 440 , octave = 3 , ratios = JUST ) : index = get_chord_root_index ( name ) freq = ratios [ index ] freq = root * ( freq [ 0 ] / freq [ 1 ] ) * 2 ** octave return freq get_intervals def get_intervals ( name ) View Source def get_intervals ( name ) : quality = get_quality ( name ) extension = get_extension ( name ) chord = BASE_QUALITIES [ quality ] if extension != '' : chord = chord + EXTENSIONS [ extension ] return chord get_quality def get_quality ( name ) View Source def get_quality ( name ): quality = '-' if name . islower () else '^' quality = '*' if re . match ( match_roman + '[*]' , name ) is not None else quality return quality get_ratio_from_interval def get_ratio_from_interval ( interval , ratios ) View Source def get_ratio_from_interval ( interval , ratios ) : try : index = INTERVALS [ interval ] except IndexError : log ( 'Interval out of range, doh. Here have a P1' ) index = 0 try : ratio = ratios [ index ] ratio = ratio [ 0 ] / ratio [ 1 ] except IndexError : base_index = index % 12 ratio = ratios [ base_index ] ratio = ratio [ 0 ] / ratio [ 1 ] register = ( index - base_index ) / 12 ratio *= 2 ** register return ratio getmultiplier def getmultiplier ( ratios , scale , degree ) View Source def getmultiplier ( ratios , scale , degree ) : base = scale [ (degree - 1) % len(scale) ] octave = degree // ( len ( scale ) + 1 ) mult = ratios [ base ] if isinstance ( mult , tuple ) : mult = mult [ 0 ] / mult [ 1 ] mult = mult * 2 ** octave return mult int_to_byte_list def int_to_byte_list ( val ) View Source def int_to_byte_list ( val ): return list ( map ( int , list ( bin ( val ))[ 2 :])) mtf def mtf ( midi_note ) View Source def mtf ( midi_note ): return 2 ** (( midi_note - 69 ) / 12 . 0 ) * 440 . 0 mtof def mtof ( midi_note ) View Source def mtof ( midi_note ): return 2 ** (( midi_note - 69 ) / 12 . 0 ) * 440 next_chord def next_chord ( name ) View Source def next_chord ( name ) : name = strip_chord ( name ) return random . choice ( PROGRESSIONS [ name ] ) ntf def ntf ( note , octave = None , ratios = None ) Note to freq View Source def ntf ( note , octave = None , ratios = None ) : \"\"\" Note to freq \"\"\" if ratios is None : ratios = TERRY note , octave = parse_pitch_class ( note , octave ) note_index = nti ( note ) mult = ratios [ note_index ][ 0 ] / ratios [ note_index ][ 1 ] if note_index >= 3 : octave -= 1 return mult * a0 * 2.0 ** octave nti def nti ( note ) Note to index returns the index of enharmonic note names or False if not found View Source def nti ( note ): \"\"\" Note to index returns the index of enharmonic note names or False if not found \"\"\" return NOTES . get ( note , False ) ntm def ntm ( note , octave = None ) View Source def ntm ( note , octave = None ): note , octave = parse_pitch_class ( note , octave ) note_index = nti ( note ) if note_index >= 3 : octave -= 1 return note_index + 21 + ( octave * 12 ) nts def nts ( note , octave ) View Source def nts ( note , octave ) : octave = octave if octave >= - 2 else - 2 octave = octave if octave <= 8 else 8 degree = NOTES [ note ] * 2 degree = degree + (( octave + 2 ) * 24 ) return degree parse_pitch_class def parse_pitch_class ( note , octave = None ) View Source def parse_pitch_class ( note , octave = None ): note = note . lower () if re . match ( '[a-zA-Z]#?b?\\d+' , note ) is not None : parsed = re . match ( '([a-zA-Z]#?b?)(\\d+)' , note ) note = parsed . group ( 1 ) octave = int ( parsed . group ( 2 )) if octave is None : octave = 4 return note , octave scale_mask_to_indexes def scale_mask_to_indexes ( mask ) View Source def scale_mask_to_indexes ( mask ): mask = to_scale_mask ( mask ) scale_indexes = [] for i , m in enumerate ( mask ): if m == 1 : scale_indexes += [ i ] return scale_indexes stf def stf ( index ) View Source def stf ( index ): degree = index % 24 octave = index / 24 return ( 2 ** ( degree / 24 . 0 )) * ( a0 / 4 . 0 ) * ( 2 . 0 ** octave ) str_to_byte_list def str_to_byte_list ( val ) View Source def str_to_byte_list ( val ): return list ( map ( int , val )) strip_chord def strip_chord ( name ) View Source def strip_chord ( name ): root = re . sub ( '[#b+/*^0-9]+' , '' , name ) return root . lower () to_scale_mask def to_scale_mask ( mapping ) View Source def to_scale_mask ( mapping ): mask = [] if isinstance ( mapping , int ): mask = int_to_byte_list ( mapping ) elif isinstance ( mapping , bytes ): for i in list ( mapping ): mask += int_to_byte_list ( i ) elif isinstance ( mapping , str ): mask = str_to_byte_list ( mapping ) elif isinstance ( mapping , list ) or isinstance ( mapping , tuple ): mask = list ( map ( int , mapping )) else : raise NotImplemented return mask tofreqs def tofreqs ( degrees = None , root = 261.63 , ratios = None , scale = None , scale_mask = None ) View Source def tofreqs ( degrees = None , root = 261 . 63 , ratios = None , scale = None , scale_mask = None ): if ratios is None : ratios = JUST if scale is None : scale = MAJOR if degrees is None : degrees = range ( len ( scale )) if scale_mask is not None : scale = scale_mask_to_indexes ( scale_mask ) freqs = [] for degree in degrees : freq = root * getmultiplier ( ratios , scale , degree ) freqs += [ freq ] return freqs Classes Parser class Parser ( score , durations = None , octave = 3 , ratios = None ) View Source class Parser: def __init__ ( self , score , durations = None , octave = 3 , ratios = None ): self . score = score self . octave = octave if durations is None: durations = ( 0.5 ,) self . durations = durations if ratios is None: ratios = TERRY self . ratios = ratios def parse ( self ): pos = 0 events = [] for note in self . score . split ( ' ' ): cluster = note . split ( ',' ) events += [( pos , cluster )] self . parsed = parsed Methods parse def parse ( self ) View Source def parse ( self ): pos = 0 events = [] for note in self . score . split ( ' ' ): cluster = note . split ( ',' ) events += [( pos , cluster )] self . parsed = parsed","title":"Index"},{"location":"reference/pippi/tune/#module-pippitune","text":"View Source import re import math import random a0 = 27.5 a4 = a0 * 2 ** 4 default_key = 'c' match_roman = '[ivIV]?[ivIV]?[iI]?' INTERVALS = { 'P1' : 0 , 'm2' : 1 , 'M2' : 2 , 'm3' : 3 , 'M3' : 4 , 'P4' : 5 , 'TT' : 6 , 'P5' : 7 , 'm6' : 8 , 'M6' : 9 , 'm7' : 10 , 'M7' : 11 , 'P8' : 12 , 'm9' : 13 , 'M9' : 14 , 'm10' : 15 , 'M10' : 16 , 'P11' : 17 , 'd12' : 18 , # TT + P8 'P12' : 19 , 'm13' : 20 , 'M13' : 21 , 'm14' : 22 , 'M14' : 23 , 'P15' : 24 } # what's the best way to handle inversions? BASE_QUALITIES = { '^' : [ 'P1' , 'M3' , 'P5' ], # major '-' : [ 'P1' , 'm3' , 'P5' ], # minor '*' : [ 'P1' , 'm3' , 'TT' ], # diminished '+' : [ 'P1' , 'M3' , 'm6' ], # augmented } EXTENSIONS = { '7' : [ 'm7' ], # dominant 7th '^7' : [ 'M7' ], # major 7th '9' : [ 'm7' , 'M9' ], # dominant 9th '^9' : [ 'M7' , 'M9' ], # major 9th '11' : [ 'm7' , 'M9' , 'P11' ], # dominant 11th '^11' : [ 'M7' , 'M9' , 'P11' ], '69' : [ 'M6' , 'M9' ], # dominant 6/9 '6' : [ 'M6' ], } CHORD_ROMANS = { 'i' : 0 , 'ii' : 2 , 'iii' : 4 , 'iv' : 5 , 'v' : 7 , 'vi' : 9 , 'vii' : 11 , } # Common root movements PROGRESSIONS = { 'I' : [ 'iii' , 'vi' , 'ii' , 'IV' , 'V' , 'vii*' ], 'i' : [ 'VII' , 'III' , 'VI' , 'ii*' , 'iv' , 'V' , 'vii*' ], 'ii' : [ 'V' , 'vii*' ], 'iii' : [ 'vi' ], 'III' : [ 'VI' ], 'IV' : [ 'V' , 'vii*' ], 'iv' : [ 'V' , 'vii*' ], 'V' : [ 'I' , 'i' ], # a pivot 'v' : [ 'I' , 'i' ], # a pivot 'vi' : [ 'ii' , 'IV' ], 'VI' : [ 'ii*' , 'iv' ], 'vii*' : [ 'I' , 'i' ], # a pivot 'vii' : [ 'I' , 'i' ], # a pivot } EQUAL = tuple ([ 2 ** ( i / 12 ) for i in range ( 12 ) ]) JUST = ( ( 1.0 , 1.0 ), # P1 ( 16.0 , 15.0 ), # m2 ( 9.0 , 8.0 ), # M2 ( 6.0 , 5.0 ), # m3 ( 5.0 , 4.0 ), # M3 ( 4.0 , 3.0 ), # P4 ( 45.0 , 32.0 ), # TT ( 3.0 , 2.0 ), # P5 ( 8.0 , 5.0 ), # m6 ( 5.0 , 3.0 ), # M6 ( 9.0 , 5.0 ), # m7 ( 15.0 , 8.0 ), # M7 ) TERRY = ( ( 1.0 , 1.0 ), # P1 C ( 16.0 , 15.0 ), # m2 Db ( 10.0 , 9.0 ), # M2 D ( 6.0 , 5.0 ), # m3 Eb ( 5.0 , 4.0 ), # M3 E ( 4.0 , 3.0 ), # P4 F ( 64.0 , 45.0 ), # TT Gb ( 3.0 , 2.0 ), # P5 G ( 8.0 , 5.0 ), # m6 Ab ( 27.0 , 16.0 ), # M6 A ( 16.0 , 9.0 ), # m7 Bb ( 15.0 , 8.0 ), # M7 B ) YOUNG = ( ( 1.0 , 1.0 ), # P1 0 ( 567.0 , 512.0 ), # m2 1 ( 9.0 , 8.0 ), # M2 2 ( 147.0 , 128.0 ), # m3 3 ( 21.0 , 16.0 ), # M3 4 ( 1323.0 , 1024.0 ), # P4 5 ( 189.0 , 128.0 ), # TT 6 ( 3.0 , 2.0 ), # P5 7 ( 49.0 , 32.0 ), # m6 8 ( 7.0 , 4.0 ), # M6 9 ( 441.0 , 256.0 ), # m7 10 ( 63.0 , 32.0 ), # M7 11 ) LOUIS = ( ( 1 , 1 ), ( math . sqrt ( 5 ) * 0.5 , 1 ), ( math . sqrt ( 6 ) * 0.5 , 1 ), ( math . sqrt ( 7 ) * 0.5 , 1 ), ( math . sqrt ( 2 ), 1 ), ( math . sqrt ( 9 ) * 0.5 , 1 ), ( math . sqrt ( 10 ) * 0.5 , 1 ), ( math . sqrt ( 11 ) * 0.5 , 1 ), ( math . sqrt ( 3 ), 1 ), ( math . sqrt ( 13 ) * 0.5 , 1 ), ( math . sqrt ( 14 ) * 0.5 , 1 ), ( math . sqrt ( 15 ) * 0.5 , 1 ), ) ## scale mappings # standard MAJOR = ( 0 , 2 , 4 , 5 , 7 , 9 , 11 ) MINOR = ( 0 , 2 , 3 , 5 , 7 , 8 , 10 ) CHROMATIC = tuple ( range ( 12 )) # notated as semitone deviations from # a MAJOR scale for readability SCALES = { 'MAJOR' : MAJOR , 'MINOR' : MINOR , 'super_locrian' : ( 0 , 2 - 1 , 4 - 1 , 5 - 1 , 7 - 1 , 9 - 1 , 11 - 1 ), 'neapolitan_minor' : ( 0 , 2 - 1 , 4 - 1 , 5 , 7 , 9 - 1 , 11 ), 'neapolitan_major' : ( 0 , 2 - 1 , 4 - 1 , 5 , 7 , 9 , 11 ), 'oriental' : ( 0 , 2 - 1 , 4 , 5 , 7 - 1 , 9 , 11 - 1 ), 'double_harmonic' : ( 0 , 2 - 1 , 4 , 5 , 7 , 9 - 1 , 11 ), 'enigmatic' : ( 0 , 2 - 1 , 4 , 5 + 1 , 7 + 1 , 9 + 1 , 11 ), } # Maps to CHROMATIC ratio lists above NOTES = { 'a' : 0 , 'a#' : 1 , 'bb' : 1 , 'b' : 2 , 'c' : 3 , 'c#' : 4 , 'db' : 4 , 'd' : 5 , 'd#' : 6 , 'eb' : 6 , 'e' : 7 , 'f' : 8 , 'f#' : 9 , 'gb' : 9 , 'g' : 10 , 'g#' : 11 , 'ab' : 11 , } MIDI_NOTES = { 'a' : 21 , 'a#' : 22 , 'bb' : 22 , 'b' : 23 , 'c' : 24 , 'c#' : 25 , 'db' : 25 , 'd' : 26 , 'd#' : 27 , 'eb' : 27 , 'e' : 28 , 'f' : 29 , 'f#' : 30 , 'gb' : 30 , 'g' : 31 , 'g#' : 32 , 'ab' : 32 , } def mtof ( midi_note ): return 2 ** (( midi_note - 69 ) / 12.0 ) * 440 def ftom ( freq ): return math . log ( freq / 440.0 , 2 ) * 12 + 69 def ftomi ( freq ): return int ( round ( ftom ( freq ))) def parse_pitch_class ( note , octave = None ): note = note . lower () if re . match ( '[a-zA-Z]#?b?\\d+' , note ) is not None : parsed = re . match ( '([a-zA-Z]#?b?)(\\d+)' , note ) note = parsed . group ( 1 ) octave = int ( parsed . group ( 2 )) if octave is None : octave = 4 return note , octave def ntm ( note , octave = None ): note , octave = parse_pitch_class ( note , octave ) note_index = nti ( note ) if note_index >= 3 : octave -= 1 return note_index + 21 + ( octave * 12 ) def edo ( degree , divs = 12 ): return 2 ** ( degree / float ( divs )) def edo_ratios ( divs = 12 ): return [ ( edo ( i , divs ), 1.0 ) for i in range ( 1 , divs + 1 ) ] def edo_scale ( divs = 12 ): return [ edo ( i , divs ) for i in range ( 1 , divs + 1 ) ] def nti ( note ): \"\"\" Note to index returns the index of enharmonic note names or False if not found \"\"\" return NOTES . get ( note , False ) def ntf ( note , octave = None , ratios = None ): \"\"\" Note to freq \"\"\" if ratios is None : ratios = TERRY note , octave = parse_pitch_class ( note , octave ) note_index = nti ( note ) mult = ratios [ note_index ][ 0 ] / ratios [ note_index ][ 1 ] if note_index >= 3 : octave -= 1 return mult * a0 * 2.0 ** octave def stf ( index ): degree = index % 24 octave = index / 24 return ( 2 ** ( degree / 24.0 )) * ( a0 / 4.0 ) * ( 2.0 ** octave ) def mtf ( midi_note ): return 2 ** (( midi_note - 69 ) / 12.0 ) * 440.0 def fts ( freq ): # Try to find closest eq temp freq to input # Generate entire range of possible eq temp freqs all_freq = [ stf ( index ) for index in range ( 2 ** 8 ) ] count = 0 cfreq = 0 while freq > cfreq and count < 2 ** 8 : cfreq = all_freq [ count ] count = count + 1 count = count - 1 return count % 55 def nts ( note , octave ): octave = octave if octave >= - 2 else - 2 octave = octave if octave <= 8 else 8 degree = NOTES [ note ] * 2 degree = degree + (( octave + 2 ) * 24 ) return degree def getmultiplier ( ratios , scale , degree ): base = scale [( degree - 1 ) % len ( scale )] octave = degree // ( len ( scale ) + 1 ) mult = ratios [ base ] if isinstance ( mult , tuple ): mult = mult [ 0 ] / mult [ 1 ] mult = mult * 2 ** octave return mult def int_to_byte_list ( val ): return list ( map ( int , list ( bin ( val ))[ 2 :])) def str_to_byte_list ( val ): return list ( map ( int , val )) def to_scale_mask ( mapping ): mask = [] if isinstance ( mapping , int ): mask = int_to_byte_list ( mapping ) elif isinstance ( mapping , bytes ): for i in list ( mapping ): mask += int_to_byte_list ( i ) elif isinstance ( mapping , str ): mask = str_to_byte_list ( mapping ) elif isinstance ( mapping , list ) or isinstance ( mapping , tuple ): mask = list ( map ( int , mapping )) else : raise NotImplemented return mask def scale_mask_to_indexes ( mask ): mask = to_scale_mask ( mask ) scale_indexes = [] for i , m in enumerate ( mask ): if m == 1 : scale_indexes += [ i ] return scale_indexes def tofreqs ( degrees = None , root = 261.63 , ratios = None , scale = None , scale_mask = None ): if ratios is None : ratios = JUST if scale is None : scale = MAJOR if degrees is None : degrees = range ( len ( scale )) if scale_mask is not None : scale = scale_mask_to_indexes ( scale_mask ) freqs = [] for degree in degrees : freq = root * getmultiplier ( ratios , scale , degree ) freqs += [ freq ] return freqs def fromdegrees ( scale_degrees = None , octave = 2 , root = 'c' , scale = None , ratios = None ): # TODO maybe depricate in favor of to_freqs() if scale_degrees is None : scale_degrees = [ 1 , 3 , 5 ] if ratios is None : ratios = TERRY if scale is None : scale = MAJOR freqs = [] root = ntf ( root , octave ) for index , degree in enumerate ( scale_degrees ): # strings are okay degree = int ( degree ) # register offset 0+ register = degree // ( len ( scale ) + 1 ) chromatic_degree = scale [( degree - 1 ) % len ( scale )] ratio = ratios [ chromatic_degree ] freqs += [ root * ( ratio [ 0 ] / ratio [ 1 ]) * 2 ** register ] return freqs def get_quality ( name ): quality = '-' if name . islower () else '^' quality = '*' if re . match ( match_roman + '[*]' , name ) is not None else quality return quality def get_extension ( name ): return re . sub ( match_roman + '[/*+]?' , '' , name ) def get_intervals ( name ): quality = get_quality ( name ) extension = get_extension ( name ) chord = BASE_QUALITIES [ quality ] if extension != '' : chord = chord + EXTENSIONS [ extension ] return chord def get_freq_from_chord_name ( name , root = 440 , octave = 3 , ratios = JUST ): index = get_chord_root_index ( name ) freq = ratios [ index ] freq = root * ( freq [ 0 ] / freq [ 1 ]) * 2 ** octave return freq def strip_chord ( name ): root = re . sub ( '[#b+/*^0-9]+' , '' , name ) return root . lower () def get_chord_root_index ( name ): root = CHORD_ROMANS [ strip_chord ( name )] if '#' in name : root += 1 if 'b' in name : root -= 1 return root % 12 def add_intervals ( a , b ): a = INTERVALS [ a ] b = INTERVALS [ b ] c = a + b for interval , index in INTERVALS . items (): if c == index : c = interval return c def get_ratio_from_interval ( interval , ratios ): try : index = INTERVALS [ interval ] except IndexError : log ( 'Interval out of range, doh. Here have a P1' ) index = 0 try : ratio = ratios [ index ] ratio = ratio [ 0 ] / ratio [ 1 ] except IndexError : base_index = index % 12 ratio = ratios [ base_index ] ratio = ratio [ 0 ] / ratio [ 1 ] register = ( index - base_index ) / 12 ratio *= 2 ** register return ratio def next_chord ( name ): name = strip_chord ( name ) return random . choice ( PROGRESSIONS [ name ]) def chord ( name , key = None , octave = 3 , ratios = None ): if key is None : key = default_key if ratios is None : ratios = TERRY key = ntf ( key , octave , ratios ) root = ratios [ get_chord_root_index ( name )] root = key * ( root [ 0 ] / root [ 1 ]) name = re . sub ( '[#b]+' , '' , name ) chord = get_intervals ( name ) chord = [ get_ratio_from_interval ( interval , ratios ) for interval in chord ] chord = [ root * ratio for ratio in chord ] return chord def chords ( names , key = None , octave = 3 , ratios = JUST ): if key is None : key = default_key return [ chord ( name , key , octave , ratios ) for name in names ] def fit_scale ( freq , scale ): # Thanks to @kennytm from stack overflow for this <3 <3 return min ( scale , key = lambda x : abs ( x - freq )) def fit ( freq , low = 20 , high = 20000 , get_change = False ): \"\"\" fit the given freq within the given freq range, by transposing up or down octaves \"\"\" # need to fit at least an octave if high < low * 2 : high = low * 2 def shift ( freq , low , high , octave_shift = 0 ): if freq < low : return shift ( freq * 2 , low , high , octave_shift + 1 ) if freq > high : return shift ( freq * 0.5 , low , high , octave_shift - 1 ) return freq , octave_shift freq , octave = shift ( freq , low , high ) if octave == 0 : mult = 1 elif octave > 0 : mult = 2 ** octave elif octave < 0 : mult = 1.0 / ( 2 ** abs ( octave )) if get_change == True : return freq , mult else : return freq class Parser : def __init__ ( self , score , durations = None , octave = 3 , ratios = None ): self . score = score self . octave = octave if durations is None : durations = ( 0.5 ,) self . durations = durations if ratios is None : ratios = TERRY self . ratios = ratios def parse ( self ): pos = 0 events = [] for note in self . score . split ( ' ' ): cluster = note . split ( ',' ) events += [( pos , cluster )] self . parsed = parsed","title":"Module pippi.tune"},{"location":"reference/pippi/tune/#sub-modules","text":"pippi.tune.scala","title":"Sub-modules"},{"location":"reference/pippi/tune/#variables","text":"BASE_QUALITIES CHORD_ROMANS CHROMATIC EQUAL EXTENSIONS INTERVALS JUST LOUIS MAJOR MIDI_NOTES MINOR NOTES PROGRESSIONS SCALES TERRY YOUNG a0 a4 default_key match_roman","title":"Variables"},{"location":"reference/pippi/tune/#functions","text":"","title":"Functions"},{"location":"reference/pippi/tune/#add_intervals","text":"def add_intervals ( a , b ) View Source def add_intervals ( a , b ) : a = INTERVALS [ a ] b = INTERVALS [ b ] c = a + b for interval , index in INTERVALS . items () : if c == index : c = interval return c","title":"add_intervals"},{"location":"reference/pippi/tune/#chord","text":"def chord ( name , key = None , octave = 3 , ratios = None ) View Source def chord ( name , key = None , octave = 3 , ratios = None ): if key is None : key = default_key if ratios is None : ratios = TERRY key = ntf ( key , octave , ratios ) root = ratios [ get_chord_root_index ( name )] root = key * ( root [ 0 ] / root [ 1 ]) name = re . sub ( '[#b]+' , '' , name ) chord = get_intervals ( name ) chord = [ get_ratio_from_interval ( interval , ratios ) for interval in chord ] chord = [ root * ratio for ratio in chord ] return chord","title":"chord"},{"location":"reference/pippi/tune/#chords","text":"def chords ( names , key = None , octave = 3 , ratios = (( 1.0 , 1.0 ), ( 16.0 , 15.0 ), ( 9.0 , 8.0 ), ( 6.0 , 5.0 ), ( 5.0 , 4.0 ), ( 4.0 , 3.0 ), ( 45.0 , 32.0 ), ( 3.0 , 2.0 ), ( 8.0 , 5.0 ), ( 5.0 , 3.0 ), ( 9.0 , 5.0 ), ( 15.0 , 8.0 )) ) View Source def chords ( names , key = None , octave = 3 , ratios = JUST ): if key is None : key = default_key return [ chord ( name , key , octave , ratios ) for name in names ]","title":"chords"},{"location":"reference/pippi/tune/#edo","text":"def edo ( degree , divs = 12 ) View Source def edo ( degree , divs = 12 ): return 2 ** ( degree / float ( divs ))","title":"edo"},{"location":"reference/pippi/tune/#edo_ratios","text":"def edo_ratios ( divs = 12 ) View Source def edo_ratios ( divs = 12 ): return [ ( edo ( i , divs ), 1 . 0 ) for i in range ( 1 , divs + 1 ) ]","title":"edo_ratios"},{"location":"reference/pippi/tune/#edo_scale","text":"def edo_scale ( divs = 12 ) View Source def edo_scale ( divs = 12 ): return [ edo ( i , divs ) for i in range ( 1 , divs + 1 ) ]","title":"edo_scale"},{"location":"reference/pippi/tune/#fit","text":"def fit ( freq , low = 20 , high = 20000 , get_change = False ) fit the given freq within the given freq range, by transposing up or down octaves View Source def fit ( freq , low = 20 , high = 20000 , get_change = False ): \"\"\" fit the given freq within the given freq range, by transposing up or down octaves \"\"\" # need to fit at least an octave if high < low * 2 : high = low * 2 def shift ( freq , low , high , octave_shift = 0 ): if freq < low : return shift ( freq * 2 , low , high , octave_shift + 1 ) if freq > high : return shift ( freq * 0 . 5 , low , high , octave_shift - 1 ) return freq , octave_shift freq , octave = shift ( freq , low , high ) if octave == 0 : mult = 1 elif octave > 0 : mult = 2 ** octave elif octave < 0 : mult = 1 . 0 / ( 2 ** abs ( octave )) if get_change == True : return freq , mult else : return freq","title":"fit"},{"location":"reference/pippi/tune/#fit_scale","text":"def fit_scale ( freq , scale ) View Source def fit_scale ( freq , scale ) : # Thanks to @kennytm from stack overflow for this < 3 < 3 return min ( scale , key = lambda x : abs ( x - freq ))","title":"fit_scale"},{"location":"reference/pippi/tune/#fromdegrees","text":"def fromdegrees ( scale_degrees = None , octave = 2 , root = 'c' , scale = None , ratios = None ) View Source def fromdegrees ( scale_degrees = None , octave = 2 , root = 'c' , scale = None , ratios = None ) : # TODO maybe depricate in favor of to_freqs () if scale_degrees is None : scale_degrees = [ 1,3,5 ] if ratios is None : ratios = TERRY if scale is None : scale = MAJOR freqs = [] root = ntf ( root , octave ) for index , degree in enumerate ( scale_degrees ) : # strings are okay degree = int ( degree ) # register offset 0 + register = degree // ( len ( scale ) + 1 ) chromatic_degree = scale [ (degree - 1) % len(scale) ] ratio = ratios [ chromatic_degree ] freqs += [ root * (ratio[0 ] / ratio [ 1 ] ) * 2 ** register ] return freqs","title":"fromdegrees"},{"location":"reference/pippi/tune/#ftom","text":"def ftom ( freq ) View Source def ftom ( freq ): return math . log ( freq / 440 . 0 , 2 ) * 12 + 69","title":"ftom"},{"location":"reference/pippi/tune/#ftomi","text":"def ftomi ( freq ) View Source def ftomi ( freq ): return int ( round ( ftom ( freq )))","title":"ftomi"},{"location":"reference/pippi/tune/#fts","text":"def fts ( freq ) View Source def fts ( freq ) : # Try to find closest eq temp freq to input # Generate entire range of possible eq temp freqs all_freq = [ stf(index) for index in range(2**8) ] count = 0 cfreq = 0 while freq > cfreq and count < 2 ** 8 : cfreq = all_freq [ count ] count = count + 1 count = count - 1 return count % 55","title":"fts"},{"location":"reference/pippi/tune/#get_chord_root_index","text":"def get_chord_root_index ( name ) View Source def get_chord_root_index ( name ): root = CHORD_ROMANS [ strip_chord ( name )] if '#' in name : root += 1 if 'b' in name : root -= 1 return root % 12","title":"get_chord_root_index"},{"location":"reference/pippi/tune/#get_extension","text":"def get_extension ( name ) View Source def get_extension ( name ): return re . sub ( match_roman + '[/*+]?' , '' , name )","title":"get_extension"},{"location":"reference/pippi/tune/#get_freq_from_chord_name","text":"def get_freq_from_chord_name ( name , root = 440 , octave = 3 , ratios = (( 1.0 , 1.0 ), ( 16.0 , 15.0 ), ( 9.0 , 8.0 ), ( 6.0 , 5.0 ), ( 5.0 , 4.0 ), ( 4.0 , 3.0 ), ( 45.0 , 32.0 ), ( 3.0 , 2.0 ), ( 8.0 , 5.0 ), ( 5.0 , 3.0 ), ( 9.0 , 5.0 ), ( 15.0 , 8.0 )) ) View Source def get_freq_from_chord_name ( name , root = 440 , octave = 3 , ratios = JUST ) : index = get_chord_root_index ( name ) freq = ratios [ index ] freq = root * ( freq [ 0 ] / freq [ 1 ] ) * 2 ** octave return freq","title":"get_freq_from_chord_name"},{"location":"reference/pippi/tune/#get_intervals","text":"def get_intervals ( name ) View Source def get_intervals ( name ) : quality = get_quality ( name ) extension = get_extension ( name ) chord = BASE_QUALITIES [ quality ] if extension != '' : chord = chord + EXTENSIONS [ extension ] return chord","title":"get_intervals"},{"location":"reference/pippi/tune/#get_quality","text":"def get_quality ( name ) View Source def get_quality ( name ): quality = '-' if name . islower () else '^' quality = '*' if re . match ( match_roman + '[*]' , name ) is not None else quality return quality","title":"get_quality"},{"location":"reference/pippi/tune/#get_ratio_from_interval","text":"def get_ratio_from_interval ( interval , ratios ) View Source def get_ratio_from_interval ( interval , ratios ) : try : index = INTERVALS [ interval ] except IndexError : log ( 'Interval out of range, doh. Here have a P1' ) index = 0 try : ratio = ratios [ index ] ratio = ratio [ 0 ] / ratio [ 1 ] except IndexError : base_index = index % 12 ratio = ratios [ base_index ] ratio = ratio [ 0 ] / ratio [ 1 ] register = ( index - base_index ) / 12 ratio *= 2 ** register return ratio","title":"get_ratio_from_interval"},{"location":"reference/pippi/tune/#getmultiplier","text":"def getmultiplier ( ratios , scale , degree ) View Source def getmultiplier ( ratios , scale , degree ) : base = scale [ (degree - 1) % len(scale) ] octave = degree // ( len ( scale ) + 1 ) mult = ratios [ base ] if isinstance ( mult , tuple ) : mult = mult [ 0 ] / mult [ 1 ] mult = mult * 2 ** octave return mult","title":"getmultiplier"},{"location":"reference/pippi/tune/#int_to_byte_list","text":"def int_to_byte_list ( val ) View Source def int_to_byte_list ( val ): return list ( map ( int , list ( bin ( val ))[ 2 :]))","title":"int_to_byte_list"},{"location":"reference/pippi/tune/#mtf","text":"def mtf ( midi_note ) View Source def mtf ( midi_note ): return 2 ** (( midi_note - 69 ) / 12 . 0 ) * 440 . 0","title":"mtf"},{"location":"reference/pippi/tune/#mtof","text":"def mtof ( midi_note ) View Source def mtof ( midi_note ): return 2 ** (( midi_note - 69 ) / 12 . 0 ) * 440","title":"mtof"},{"location":"reference/pippi/tune/#next_chord","text":"def next_chord ( name ) View Source def next_chord ( name ) : name = strip_chord ( name ) return random . choice ( PROGRESSIONS [ name ] )","title":"next_chord"},{"location":"reference/pippi/tune/#ntf","text":"def ntf ( note , octave = None , ratios = None ) Note to freq View Source def ntf ( note , octave = None , ratios = None ) : \"\"\" Note to freq \"\"\" if ratios is None : ratios = TERRY note , octave = parse_pitch_class ( note , octave ) note_index = nti ( note ) mult = ratios [ note_index ][ 0 ] / ratios [ note_index ][ 1 ] if note_index >= 3 : octave -= 1 return mult * a0 * 2.0 ** octave","title":"ntf"},{"location":"reference/pippi/tune/#nti","text":"def nti ( note ) Note to index returns the index of enharmonic note names or False if not found View Source def nti ( note ): \"\"\" Note to index returns the index of enharmonic note names or False if not found \"\"\" return NOTES . get ( note , False )","title":"nti"},{"location":"reference/pippi/tune/#ntm","text":"def ntm ( note , octave = None ) View Source def ntm ( note , octave = None ): note , octave = parse_pitch_class ( note , octave ) note_index = nti ( note ) if note_index >= 3 : octave -= 1 return note_index + 21 + ( octave * 12 )","title":"ntm"},{"location":"reference/pippi/tune/#nts","text":"def nts ( note , octave ) View Source def nts ( note , octave ) : octave = octave if octave >= - 2 else - 2 octave = octave if octave <= 8 else 8 degree = NOTES [ note ] * 2 degree = degree + (( octave + 2 ) * 24 ) return degree","title":"nts"},{"location":"reference/pippi/tune/#parse_pitch_class","text":"def parse_pitch_class ( note , octave = None ) View Source def parse_pitch_class ( note , octave = None ): note = note . lower () if re . match ( '[a-zA-Z]#?b?\\d+' , note ) is not None : parsed = re . match ( '([a-zA-Z]#?b?)(\\d+)' , note ) note = parsed . group ( 1 ) octave = int ( parsed . group ( 2 )) if octave is None : octave = 4 return note , octave","title":"parse_pitch_class"},{"location":"reference/pippi/tune/#scale_mask_to_indexes","text":"def scale_mask_to_indexes ( mask ) View Source def scale_mask_to_indexes ( mask ): mask = to_scale_mask ( mask ) scale_indexes = [] for i , m in enumerate ( mask ): if m == 1 : scale_indexes += [ i ] return scale_indexes","title":"scale_mask_to_indexes"},{"location":"reference/pippi/tune/#stf","text":"def stf ( index ) View Source def stf ( index ): degree = index % 24 octave = index / 24 return ( 2 ** ( degree / 24 . 0 )) * ( a0 / 4 . 0 ) * ( 2 . 0 ** octave )","title":"stf"},{"location":"reference/pippi/tune/#str_to_byte_list","text":"def str_to_byte_list ( val ) View Source def str_to_byte_list ( val ): return list ( map ( int , val ))","title":"str_to_byte_list"},{"location":"reference/pippi/tune/#strip_chord","text":"def strip_chord ( name ) View Source def strip_chord ( name ): root = re . sub ( '[#b+/*^0-9]+' , '' , name ) return root . lower ()","title":"strip_chord"},{"location":"reference/pippi/tune/#to_scale_mask","text":"def to_scale_mask ( mapping ) View Source def to_scale_mask ( mapping ): mask = [] if isinstance ( mapping , int ): mask = int_to_byte_list ( mapping ) elif isinstance ( mapping , bytes ): for i in list ( mapping ): mask += int_to_byte_list ( i ) elif isinstance ( mapping , str ): mask = str_to_byte_list ( mapping ) elif isinstance ( mapping , list ) or isinstance ( mapping , tuple ): mask = list ( map ( int , mapping )) else : raise NotImplemented return mask","title":"to_scale_mask"},{"location":"reference/pippi/tune/#tofreqs","text":"def tofreqs ( degrees = None , root = 261.63 , ratios = None , scale = None , scale_mask = None ) View Source def tofreqs ( degrees = None , root = 261 . 63 , ratios = None , scale = None , scale_mask = None ): if ratios is None : ratios = JUST if scale is None : scale = MAJOR if degrees is None : degrees = range ( len ( scale )) if scale_mask is not None : scale = scale_mask_to_indexes ( scale_mask ) freqs = [] for degree in degrees : freq = root * getmultiplier ( ratios , scale , degree ) freqs += [ freq ] return freqs","title":"tofreqs"},{"location":"reference/pippi/tune/#classes","text":"","title":"Classes"},{"location":"reference/pippi/tune/#parser","text":"class Parser ( score , durations = None , octave = 3 , ratios = None ) View Source class Parser: def __init__ ( self , score , durations = None , octave = 3 , ratios = None ): self . score = score self . octave = octave if durations is None: durations = ( 0.5 ,) self . durations = durations if ratios is None: ratios = TERRY self . ratios = ratios def parse ( self ): pos = 0 events = [] for note in self . score . split ( ' ' ): cluster = note . split ( ',' ) events += [( pos , cluster )] self . parsed = parsed","title":"Parser"},{"location":"reference/pippi/tune/#methods","text":"","title":"Methods"},{"location":"reference/pippi/tune/#parse","text":"def parse ( self ) View Source def parse ( self ): pos = 0 events = [] for note in self . score . split ( ' ' ): cluster = note . split ( ',' ) events += [( pos , cluster )] self . parsed = parsed","title":"parse"},{"location":"reference/pippi/tune/scala/","text":"Module pippi.tune.scala View Source import glob import os def parse_cents ( tuning ): try : return 2 ** ( float ( tuning ) / 1200 ) except ( TypeError , ValueError ): return None def parse_ratio ( tuning ): if '/' in tuning : try : ratio = [ t for t in tuning . split ( '/' ) if t != '' ][: 2 ] return int ( ratio [ 0 ]) / int ( ratio [ 1 ]) except ( TypeError , ValueError ): return None try : return int ( tuning ) except ( TypeError , ValueError ): return None def import_file ( filename ): if '.scl' not in filename : raise ValueError ( 'This doesn \\' t look like a Scala file' ) with open ( filename , encoding = 'latin-1' ) as tuning_file : description = None scale_length = None tunings = [] for line in tuning_file : if line [ 0 ] == '!' : continue if description is None : description = line . strip () continue elif scale_length is None : try : scale_length = int ( line . strip ()) continue except ( TypeError , ValueError ) as e : raise ValueError ( 'Invalid value for scale length' ) from e tuning = line . strip () . split ( ' ' )[ 0 ] if '.' in tuning : tuning = parse_cents ( tuning ) else : tuning = parse_ratio ( tuning ) if tuning is None : continue tunings += [ tuning ] return { 'filename' : filename , 'description' : description , 'scale' : [ 1 ] + tunings [: scale_length ], } def import_directory ( directory ): scales = [] for filename in glob . glob ( os . path . join ( directory , '*.scl' )): try : scale = import_file ( filename ) scales += [ scale ] except Exception as e : print ( e ) continue return scales if __name__ == '__main__' : scales = import_directory ( './scl/' ) print ( len ( scales )) Functions import_directory def import_directory ( directory ) View Source def import_directory ( directory ): scales = [] for filename in glob . glob ( os . path . join ( directory , '*.scl' )): try : scale = import_file ( filename ) scales += [ scale ] except Exception as e : print ( e ) continue return scales import_file def import_file ( filename ) View Source def import_file ( filename ): if '.scl' not in filename : raise ValueError ( 'This doesn\\' t look like a Scala file ') with open(filename, encoding=' latin - 1 ') as tuning_file: description = None scale_length = None tunings = [] for line in tuning_file: if line[0] == ' ! ': continue if description is None: description = line.strip() continue elif scale_length is None: try: scale_length = int(line.strip()) continue except (TypeError, ValueError) as e: raise ValueError(' Invalid value for scale length ') from e tuning = line.strip().split(' ')[0] if ' . ' in tuning: tuning = parse_cents(tuning) else: tuning = parse_ratio(tuning) if tuning is None: continue tunings += [ tuning ] return { ' filename ': filename, ' description ': description, ' scale ' : [ 1 ] + tunings [: scale_length ], } parse_cents def parse_cents ( tuning ) View Source def parse_cents ( tuning ): try : return 2 ** ( float ( tuning ) / 1200 ) except ( TypeError , ValueError ): return None parse_ratio def parse_ratio ( tuning ) View Source def parse_ratio ( tuning ): if '/' in tuning : try : ratio = [ t for t in tuning . split ( '/' ) if t != '' ][: 2 ] return int ( ratio [ 0 ]) / int ( ratio [ 1 ]) except ( TypeError , ValueError ): return None try : return int ( tuning ) except ( TypeError , ValueError ): return None","title":"Scala"},{"location":"reference/pippi/tune/scala/#module-pippitunescala","text":"View Source import glob import os def parse_cents ( tuning ): try : return 2 ** ( float ( tuning ) / 1200 ) except ( TypeError , ValueError ): return None def parse_ratio ( tuning ): if '/' in tuning : try : ratio = [ t for t in tuning . split ( '/' ) if t != '' ][: 2 ] return int ( ratio [ 0 ]) / int ( ratio [ 1 ]) except ( TypeError , ValueError ): return None try : return int ( tuning ) except ( TypeError , ValueError ): return None def import_file ( filename ): if '.scl' not in filename : raise ValueError ( 'This doesn \\' t look like a Scala file' ) with open ( filename , encoding = 'latin-1' ) as tuning_file : description = None scale_length = None tunings = [] for line in tuning_file : if line [ 0 ] == '!' : continue if description is None : description = line . strip () continue elif scale_length is None : try : scale_length = int ( line . strip ()) continue except ( TypeError , ValueError ) as e : raise ValueError ( 'Invalid value for scale length' ) from e tuning = line . strip () . split ( ' ' )[ 0 ] if '.' in tuning : tuning = parse_cents ( tuning ) else : tuning = parse_ratio ( tuning ) if tuning is None : continue tunings += [ tuning ] return { 'filename' : filename , 'description' : description , 'scale' : [ 1 ] + tunings [: scale_length ], } def import_directory ( directory ): scales = [] for filename in glob . glob ( os . path . join ( directory , '*.scl' )): try : scale = import_file ( filename ) scales += [ scale ] except Exception as e : print ( e ) continue return scales if __name__ == '__main__' : scales = import_directory ( './scl/' ) print ( len ( scales ))","title":"Module pippi.tune.scala"},{"location":"reference/pippi/tune/scala/#functions","text":"","title":"Functions"},{"location":"reference/pippi/tune/scala/#import_directory","text":"def import_directory ( directory ) View Source def import_directory ( directory ): scales = [] for filename in glob . glob ( os . path . join ( directory , '*.scl' )): try : scale = import_file ( filename ) scales += [ scale ] except Exception as e : print ( e ) continue return scales","title":"import_directory"},{"location":"reference/pippi/tune/scala/#import_file","text":"def import_file ( filename ) View Source def import_file ( filename ): if '.scl' not in filename : raise ValueError ( 'This doesn\\' t look like a Scala file ') with open(filename, encoding=' latin - 1 ') as tuning_file: description = None scale_length = None tunings = [] for line in tuning_file: if line[0] == ' ! ': continue if description is None: description = line.strip() continue elif scale_length is None: try: scale_length = int(line.strip()) continue except (TypeError, ValueError) as e: raise ValueError(' Invalid value for scale length ') from e tuning = line.strip().split(' ')[0] if ' . ' in tuning: tuning = parse_cents(tuning) else: tuning = parse_ratio(tuning) if tuning is None: continue tunings += [ tuning ] return { ' filename ': filename, ' description ': description, ' scale ' : [ 1 ] + tunings [: scale_length ], }","title":"import_file"},{"location":"reference/pippi/tune/scala/#parse_cents","text":"def parse_cents ( tuning ) View Source def parse_cents ( tuning ): try : return 2 ** ( float ( tuning ) / 1200 ) except ( TypeError , ValueError ): return None","title":"parse_cents"},{"location":"reference/pippi/tune/scala/#parse_ratio","text":"def parse_ratio ( tuning ) View Source def parse_ratio ( tuning ): if '/' in tuning : try : ratio = [ t for t in tuning . split ( '/' ) if t != '' ][: 2 ] return int ( ratio [ 0 ]) / int ( ratio [ 1 ]) except ( TypeError , ValueError ): return None try : return int ( tuning ) except ( TypeError , ValueError ): return None","title":"parse_ratio"}]}