#!/usr/bin/env python2

import cmd
import os
import sys
import re
import time

from pippi import dsp
from pippi import param
from pippi import rt
import alsaaudio

import multiprocessing as mp
from termcolor import colored
from os.path import expanduser
import ConfigParser

class Pippi(cmd.Cmd):
    """ Pippi Console 
    """

    prompt = 'pippi: '
    intro = 'Pippi Console'

    cc = {} 
    vid = 0

    def __init__(self):
        cmd.Cmd.__init__(self)

        # Global pippi config settings including
        # optional global param defaults
        userhome = expanduser('~')

        self.config = ConfigParser.SafeConfigParser(allow_no_value=True)

        try:
            with open(userhome + '/.pippi', 'r+b') as configfile:
                self.config.readfp(configfile)

        except IOError:
            # Create a stub config file if none is found
            with open(userhome + '/.pippi', 'wb') as configfile:
                self.config.add_section('global')
                self.config.set('global', 'bpm', '65.0')
                self.config.add_section('orcpaths')
                self.config.set('orcpaths', userhome + '/orc/')
                self.config.set('orcpaths', os.getcwd() + '/orc/')
                self.config.write(configfile)


        self.bpm = self.config.get('global', 'bpm')

        # Update sys.path to include any generator orc/ directories
        # listed in our config
        sys.path += [ orcpath[0] for orcpath in self.config.items('orcpaths') ]

        # A set of shared namespaces to enable data 
        # passing between processes.
        self.server = mp.Manager()
        self.buffers = self.server.Namespace()
        self.params = self.server.Namespace()

        # TODO probably some sort of hash function 
        # would be better than this integer-as-id hack.
        self.voice_id = str(0)

        self.tick = mp.Event()

        self.grid = mp.Process(target=rt.grid, args=(self.tick, self.bpm))
        self.grid.start()

        self.cc = []

        # Load all available generators into a dict 
        self.generators = {}

        # Look for generators in all available orc directories 
        orcpaths = [ orcpath[0] for orcpath in self.config.items('orcpaths') ]

        for orcpath in orcpaths:
            try:
                gens = os.listdir(orcpath)

                pattern = re.compile(r'(^[a-zA-Z]+)(\.py$)')

                for gen in gens:
                    filename = pattern.search(gen)

                    if filename:
                        filename = filename.group(1)

                        # import
                        gen = __import__(filename)
                    
                        # Fetch the shortname or just use the first two letters of the filename
                        shortname = gen.shortname if hasattr(gen, 'shortname') else filename[0:2]

                        self.generators[shortname] = gen

                print 'Loaded', len(gens), 'generators from', orcpath

            except OSError:
                print 'No generators found in ' + orcpath

        print


    def do_c(self, cmd):
        cmd = cmd.split(' ')
        t = cmd[0]
        cmd.pop(0)
        self.cc += [ t ]
        print self.cc

    def do_u(self, cmd):
        cmds = cmd.split(' ')
        voice_id = cmds[0]
        self.update_param(voice_id, cmds[1], cmds[2])

    def do_ss(self, cmd):
        gen = 'all'

        cmds = cmd.split(' ')
        if cmds[0] != '' and cmds[0] != 'all':
            gen = cmds

        for voice_id in range(1, int(self.voice_id) + 1):
            voice_id = str(voice_id)
            if hasattr(self.params, voice_id):
                params = getattr(self.params, voice_id)

                if params.get('generator') in gen or gen == 'all':
                    self.update_param(voice_id, 'loop', False)

    def do_s(self, cmd):
        cmds = cmd.split(' ')

        for cmd in cmds:
            voice_id = cmd.strip() 
            self.update_param(voice_id, 'loop', False)

    def do_vv(self, cmd):
        cmds = cmd.split(' ')

        for voice_id in range(1, int(self.voice_id) + 1):
            self.setvol(str(voice_id), cmds[1], cmds[0])

    def do_v(self, cmd):
        cmds = cmd.split(' ')
        self.setvol(cmds[0], cmds[1])

    def setvol(self, voice_id, volume, generator='a'):
        if hasattr(self.params, voice_id):
            params = getattr(self.params, voice_id)
            if generator == params['generator']['name'] or generator == 'a':
                params['target_volume'] = float(volume) / 100.0
                setattr(self.params, voice_id, params)

    def do_i(self, cmd=[]):
        for voice_id in range(1, int(self.voice_id) + 1):
            voice_id = str(voice_id)
            if hasattr(self.params, voice_id):
                params = getattr(self.params, voice_id)
                print voice_id, self.format_params(params.data)

    def update_param(self, voice_id, param, value):
        if hasattr(self.params, voice_id):
            params = getattr(self.params, voice_id)
            params.set(param, value)
            setattr(self.params, voice_id, params)

    def format_params(self, params=[]):
        # TODO: translate types & better formatting
        param_string = ''
        for param in params:
            #value = params[param]['name'] if param == 'generator' else params[param]
            value = params[param]
            param_string += colored(str(param)[0:3] + ': ', 'cyan')
            param_string += colored(str(value['value']), 'yellow')
            param_string += ' '
        
        return param_string

    def do_p(self, cmd):
        if cmd in self.config['presets']:
            cmd = self.config['presets'][cmd]

            for c in cmd:
                if len(c) > 2:
                    self.default(c)
                    dsp.delay(0.1)

    def default(self, cmd):
        # Break comma separated commands
        # into a list of command strings
        cmds = cmd.strip().split(',')

        # For each command string, unpack and load
        # into a param.Param instance
        #
        # For our purposes, a 'command' refers to text typed at the pippi
        # console, while 'param' refers to the translatable key-value pairs 
        # passed to the play method of generator scripts.
        #
        # So:
        #   sh o:3
        #
        # Could become:
        #   { 'generator': 'shine', 'octave': {'value': 3, 'type': 'integer'} }
        # 
        # And:
        #   dr h:1.2.3.4 t:4b wf:tri n:eb.g
        # 
        # Could become:
        #   {
        #       'generator': 'drone',
        #       'harmonics': {'value': '1.2.3.4', 'type': 'integer-list'},
        #       'length': {'value': '4b', 'type': 'frame'},
        #       'waveform': {'value': 'tri'},
        #       'notes': {'value': 'eb.g', 'type': 'note-list'}
        #   }
        # 
        # For a complete list of reserved words and built-in types please 
        # refer to the patterns and type settings in param.py.

        for cmd in cmds:
            # Split space-separated params into a list
            commands = cmd.strip().split()

            # Split colon-separated key:value param pairs
            # into lists.
            commands = [ command.split(':') for command in commands ]

            try:
                generator = self.generators.get(commands[0][0], False)
                params = param.Param(commands) 

                print generator.name

                if 'bpm' not in params.data:
                    params.data['bpm'] = { 'value': self.bpm, 'name': 'bpm' }

                if 'loop' not in params.data:
                    if hasattr(generator, 'loop'):
                        params.data['loop'] = { 'value': generator.loop, 'name': 'loop' }
                    else:
                        params.data['loop'] = { 'value': True, 'name': 'loop' }

                if 'device' not in params.data:
                    if hasattr(generator, 'device'):
                        params.data['device'] = { 'value': generator.device, 'name': 'device' }

                if generator.shortname in params.data:
                    params.data.pop(generator.shortname)
                    params.data['generator'] = { 'value': generator.name, 'name': 'generator' }

                # Increment voice id and print voice information. TODO: pretty print & abstract
                self.voice_id = str(int(self.voice_id) + 1)
                print self.voice_id, self.format_params(params.data)

                # Allocate a new shared voice dict to store generator params, and audio
                # data for the render process. (Render processes are spawned on demand by 
                # the voice's playback process.)

                setattr(self.buffers, self.voice_id, '')
                setattr(self.params, self.voice_id, params)

                # Import the generator as a python module and spawn a playback 
                # process from rt.out, passing in the generator's play method 
                # which will be run from within a render process - spawned on demand 
                # by the voice's playback process. Sheesh.

                playback_process = mp.Process(target=rt.out, args=(generator, self.buffers, self.params, self.voice_id, self.tick))
                playback_process.start()


            except TypeError as e:
                print 'invalid generator', e
                raise

    def do_EOF(self, line):
        return True

    def postloop(self):
        pass

if __name__ == '__main__':
        # Create console
        console = Pippi()

        # Start looping command prompt
        console.cmdloop()
